{"posts":[{"title":"写博客的意义","text":"从2015年开始，写博客断断续续已经有7.8年了。其中使用过博客园、CSDN、掘金等技术论坛，也够买过服务器搭建开源的个人博客系统。作为一个爱折腾的技术人员，在博客这件事折腾的时间真的不算少。是时候想一想写博客这件小事的意义了。 为啥要写博客 这7.8年写博客的历史,是一个从业IT行业的技术人员成长过程的记录。 写博客提升了个人的语言表达能力、总结归纳能力。 写不了博客说明了对于这个知识点，了解的还不够透彻。在写一篇博客查阅了各种资料、反复实验的过程,加深了对于这个知识点的更深层次的认识。 写了一篇博客如果能够帮助其他人也有了收获，是予人玫瑰手有余香。 网友指出博客内容其中的错误与遗留，互动交流学习的过程弥补了自己的不足。 写博客的坏处 一篇充满错误的、大量重复内容的博客，对于中文互联网环境来说是网络垃圾。以前常常对于自己的博客上了搜索引擎SEO首页沾沾自喜，现在想想可能不小心误人子弟，后期时常感到羞愧。 写博客要花费大量的时间、精力，带来的收益与坏处相比，性价比很低。 每年要花费一笔服务器维护支出的钱。 个人思考 如果一篇博客分享的内容自己都认为没什么可写的，不如记成私人笔记，个人用来查漏补缺即可。 写博客知识点一定要成体系，讲清楚一件事，切记不要虎头蛇尾，半途而费。 写博客不要花费太多的金钱与博客内容本身之外的精力。 鄙视网络博客文章上来就是震惊体的标题，3天学会，最全、最好之类的字眼。脸皮薄的同学切记不要养成这种习惯。 写博客使用一个靠的住的平台，文章内容与其中的图片素材能够长久保存，最好能够定时自动备份归档。 写博客当然也不需要怕出丑，毕竟人无完人，文章缺漏错误之处，要能够虚心接受别人的批评，当然也要内心强大敢于无视网络喷子。","link":"/2023/07/15/%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%84%8F%E4%B9%89/"},{"title":"求最多线段重合次数","text":"最近在业务开发时，需要求值机柜台资源分配的使用时间段重叠部分不能超过使用次数限制。简化成算法问题，就是求多个开始-结束的线段的最大重叠时间次数。 举例：求给定[1,3] [2,4] [4,7] [2,9]等线段求最大重合次数答案是3次，1-3，2-4，2-9的重叠最大次数是3。 两种解题思路：暴力破解最多重叠的区域的结果的左端点leftx，数组其中的一个左端点。暴力遍历每一个左端点，落在最多数组时间端的就是最大重叠次数。 1234567891011121314151617181920/** * 最后重叠的线段的左节点一定是给定线段中其中一个线段的左节点 * 因此求所有左节点，落在最多的线段中，就是最大重叠次数 * O(N^2) * @param lines * @return */public static int maxLine1(int[][] lines){ if(lines==null||lines.length==0) return 0; int max=1; for(int i=0;i&lt;lines.length;i++){ int left=lines[i][0]; int t=0; for(int j=0;j&lt;lines.length;j++){ if(lines[j][0]&lt;=left&amp;&amp;lines[j][1]&gt;=left) t=t+1; max=Math.max(max,t); } } return max;} 小根堆方案2：使用小根堆满足条件的左节点一定是某个线段的左端点，那么通过该节点的线段一定左端点小于该结果leftx，右节点大于leftx。通过小根堆的特性，留在堆的一定是大于左节点的端点。 将所有线段按照左端点排序，减少遍历次数 遍历每一个线段，对于每一个线段 把右端点放入堆中， 左节点与堆顶比较，如果堆顶的元素小于左端点全部弹出 每次Max找最大重合次数作为答案123456789101112public static int maxLine2(int[][] lines){ if(lines==null||lines.length==0) return 0; Arrays.sort(lines,(a,b)-&gt;a[0]-b[0]); PriorityQueue&lt;Integer&gt; heap=new PriorityQueue&lt;&gt;(); int max=1; for(int i=0;i&lt;lines.length;i++){ while (!heap.isEmpty()&amp;&amp;heap.peek()&lt;=lines[i][0]) heap.poll(); heap.add(lines[i][1]); max=Math.max(heap.size(),max); } return max;}","link":"/2023/09/27/alg/%E7%AE%97%E6%B3%95%EF%BC%9A%E6%B1%82%E6%9C%80%E5%A4%9A%E7%BA%BF%E6%AE%B5%E9%87%8D%E5%90%88%E6%AC%A1%E6%95%B0/"},{"title":"SpringBoot2.x基础教程：连接池配置","text":"HikariCP连接池基本配置12345678910#数据源驱动名称spring.datasource.driver-class-name=com.mysql.jdbc.Driver#连接池类型spring.datasource.type=com.zaxxer.hikari.HikariDataSource#数据源地址spring.datasource.url=jdbc:mysql://localhost:3306/test#数据源连接名spring.datasource.username=root#数据源地址spring.datasource.password=123456 HikariCP配置12345678910#最小空闲连接spring.datasource.hikari.mininum-idle=10#最大连接数spring.datasource.hikari.maximun-pool-size=10#空闲超时时间，这个属性用来控制空闲连接允许保留在连接池中的最大时间，这个属性只有在minimumIdle（最小空闲连接数）小于maximumPoolSize(最大连接数)时才会生效,空闲连接断开会有15s-30s的延迟变动时间.在这个超时时间之前空闲连接永远不会断开,当连接池达到minimumIdle,连接将永远不会断开，即使处于闲置状态.值为0表示空闲连接将永远不会从连接池中移除，最小值为10000ms （10s),默认值为600000(10min)spring.datasource.idle-timeout=300000#最大生命周期.这个属性用来控制连接池中连接的最大生命周期,一个使用中的连接永远不会被断开,只有当它处于关闭状态然后才会被移除.推荐设置比任何数据库或基础设施规定的连接时间限制少至少30秒。 值为0表示没有最大寿命（无限寿命）， 默认：1800000（30分钟）,由于HikariCP的housekeeper默认每30s运行一次,以维护minimumIdle最小空闲连接数，它可能添加新连接或者断开空闲连接，所以你必须设置maxLifetime属性比（mysql)wait_timeout时间少一些来避免 broken connection / exceptions.意思就是说比如mysql wait_timeout为10min,此时有一个连接由于达到超时时间，mysql主动断开了连接，而HakariCP仍然持有此连接，如果再使用此连接去请求数据库则会发生异常,设置maxLifetime最大生命周期比wait_timeout少30s后,就能确保再housekeeper运行期间提前断开此连接，避免发生异常.spring.datasource.hikari.max-lifetime=600000#连接池名称spring.datasource.hikari.poolName=CDHikariPool Druid引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.17&lt;/version&gt;&lt;/dependency&gt; Druid配置1234567891011121314151617181920212223242526272829303132333435363738spring: datasource: driver-class-name: oracle.jdbc.OracleDriver maxActive: 20 type: com.alibaba.druid.pool.DruidDataSource url: jdbc:oracle:thin:@192.28.4.21:1521:fdp1 username: imf password: ca2804 druid: filters: stat,wall,slf4j # 通过 connectProperties 属性来打开 mergeSql 功能；慢 SQL 记录 connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 initial-size: 20 max-active: 20 min-idle: 20 max-wait: 60000 #是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭 pool-prepared-statements: true #要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 max-pool-prepared-statement-per-connection-size: 100 #测试连接 validation-query: select 'x' from dual validation-query-timeout: 10 #申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。 test-on-borrow: true test-while-idle: true #归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 test-on-return: false web-stat-filter: enabled: true url-pattern: &quot;/*&quot; exclusions: &quot;*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*&quot; stat-view-servlet: url-pattern: &quot;/druid/*&quot; login-username: atc login-password: atc4 reset-enable: false enabled: true Druid监控页面浏览器访问应用地址http://:/druid/login.html即可以访问监控页面。","link":"/2023/09/25/springboot/SpringBoot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%85%8D%E7%BD%AE/"},{"title":"SpringBoot通过proguard-maven-plugin插件进行实际项目代码混淆，实测可用","text":"本文主要研究下如何使用proguard-maven-plugin插件混淆springboot代码。工程代码是实际跑在线上的Springboot2.x项目，踩过N个坑，最后实测成功。 先说贴出成功的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;build&gt; &lt;finalName&gt;spring&lt;/finalName&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;excludes&gt; &lt;exclude&gt;**/application-*.yml&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;!--代码混淆--&gt; &lt;plugin&gt; &lt;groupId&gt;com.github.wvengen&lt;/groupId&gt; &lt;artifactId&gt;proguard-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt;&lt;goal&gt;proguard&lt;/goal&gt;&lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;proguardVersion&gt;6.0.3&lt;/proguardVersion&gt; &lt;injar&gt;${project.build.finalName}.jar&lt;/injar&gt; &lt;!-- &lt;injar&gt;classes&lt;/injar&gt; --&gt; &lt;outjar&gt;${project.build.finalName}.jar&lt;/outjar&gt; &lt;obfuscate&gt;true&lt;/obfuscate&gt; &lt;options&gt; &lt;!-- ##默认是开启的，这里关闭shrink，即不删除没有使用的类/成员--&gt; &lt;option&gt;-dontshrink&lt;/option&gt; &lt;!-- ##默认是开启的，这里关闭字节码级别的优化--&gt; &lt;option&gt;-dontoptimize&lt;/option&gt; &lt;!--##对于类成员的命名的混淆采取唯一策略--&gt; &lt;option&gt;-useuniqueclassmembernames&lt;/option&gt; &lt;!--- 混淆类名之后，对使用Class.forName('className')之类的地方进行相应替代--&gt; &lt;option&gt;-adaptclassstrings &lt;/option&gt; &lt;option&gt;-ignorewarnings&lt;/option&gt; &lt;!-- 混淆时不生成大小写混合的类名，默认是可以大小写混合--&gt; &lt;option&gt;-dontusemixedcaseclassnames&lt;/option&gt; &lt;!-- This option will replace all strings in reflections method invocations with new class names. For example, invokes Class.forName('className')--&gt; &lt;!-- &lt;option&gt;-adaptclassstrings&lt;/option&gt; --&gt; &lt;!-- This option will save all original annotations and etc. Otherwise all we be removed from files.--&gt; &lt;!-- 不混淆所有特殊的类--&gt; &lt;option&gt;-keepattributes Exceptions,InnerClasses,Signature,Deprecated, SourceFile,LineNumberTable,*Annotation*,EnclosingMethod&lt;/option&gt; &lt;!-- This option will save all original names in interfaces (without obfuscate).--&gt; &lt;option&gt;-keepnames interface **&lt;/option&gt; &lt;!-- This option will save all original methods parameters in files defined in -keep sections, otherwise all parameter names will be obfuscate.--&gt; &lt;option&gt;-keepparameternames&lt;/option&gt; &lt;!-- &lt;option&gt;-libraryjars **&lt;/option&gt; --&gt; &lt;!-- This option will save all original class files (without obfuscate) but obfuscate all in domain package.--&gt; &lt;!--&lt;option&gt;-keep class !com.slm.proguard.example.spring.boot.domain.** { *; }&lt;/option&gt;--&gt; &lt;option&gt;-keep class !com.dsys.project.** { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.App { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.config.** { *; }&lt;/option&gt; &lt;!--保留不然Mybatis报错--&gt; &lt;option&gt;-keep class com.dsys.project.entity.** { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.utils.PageRes { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.controller.** { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.mp.controller.** { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.mp.config.** { *; }&lt;/option&gt; &lt;option&gt;-keep class com.dsys.project.dto.** { *; }&lt;/option&gt; &lt;option&gt;-keep class * implements java.io.Serializable &lt;/option&gt; &lt;!-- This option will save all original class files (without obfuscate) in service package--&gt; &lt;!--&lt;option&gt;-keep class com.slm.proguard.example.spring.boot.service { *; }&lt;/option&gt;--&gt; &lt;!-- This option will save all original interfaces files (without obfuscate) in all packages.--&gt; &lt;option&gt;-keep interface * extends * { *; }&lt;/option&gt; &lt;!-- &lt;option&gt;-keep @org.springframework.stereotype.Service class *&lt;/option&gt; --&gt; &lt;!-- This option will save all original defined annotations in all class in all packages.--&gt; &lt;option&gt;-keepclassmembers class * { &lt;!-- @org.springframework.beans.factory.annotation.Autowired *; --&gt; @org.springframework.beans.factory.annotation.Value *; } &lt;/option&gt; &lt;/options&gt; &lt;libs&gt; &lt;!-- Include main JAVA library required.--&gt; &lt;lib&gt;${java.home}/lib/rt.jar&lt;/lib&gt; &lt;/libs&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.proguard&lt;/groupId&gt; &lt;artifactId&gt;proguard-base&lt;/artifactId&gt; &lt;version&gt;6.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;!-- &lt;phase&gt;none&lt;/phase&gt; --&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;mainClass&gt;com.dsys.project.App&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 主要的坑,springboot项目配置注意项启动类不能混淆123456789101112131415161718192021222324252627//混淆会把Bean的名称重复，这里要求SpringBoot生成唯一的BeanName@SpringBootApplication@MapperScan(&quot;com.dsys.project.dao&quot;)@ComponentScan(&quot;com.dsys&quot;)@ServletComponentScan(&quot;com.dsys&quot;)@EnableCaching@EnableAsyncpublic class App { public static class CustomGenerator implements BeanNameGenerator { @Override public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) { return definition.getBeanClassName(); } } /*** * 由于proguard混淆貌似不能指定在basePackages下面类名混淆后唯一，不同包名经常有a.class，b.class,c.class之类重复的类名，因此spring容器初始化bean的时候会报错。 *庆幸的是，我们可以通过改变spring的bean的命名策略来解决这个问题，把包名带上，就唯一了 * @param args */ public static void main(String[] args) { new SpringApplicationBuilder(App.class) .beanNameGenerator(new CustomGenerator()) .run(args); }} 实体类一定要保留123解释：这里的实体类包括各种Entity,Dto等。保留的原因有：1. Mybatis的XML的ResultType需要实体类的全路径2. Jackson需要序列化，字段混淆前端会找不到 Controller一定要保留1解释：Controller混淆了前端找不到请求路径，模板引擎例如thymeleaf找不到路径 SpringBoot JavaConfig配置不能混淆1234567891011//解释：例如下面的JavaConfig配置，混淆后配置出错@Data@ConfigurationProperties(prefix = &quot;wx.mp&quot;)public class WxMpProperties { private List&lt;MpConfig&gt; configs; @Data public static class MpConfig { private String appId; }} 其他配置参考以上的注释，其他照抄修改成自己的项目对应路径即可，使用JD-GUI反编译查看效果。","link":"/2023/09/25/springboot/SpringBoot%E9%80%9A%E8%BF%87proguard-maven-plugin%E6%8F%92%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%EF%BC%8C%E5%AE%9E%E6%B5%8B%E5%8F%AF%E7%94%A8/"},{"title":"Springboot2.x基础教程：SpringBoot集成Quartz","text":"引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;&lt;/dependency&gt; Quartz配置12345678910111213141516171819202122spring: quartz: properties: org: quartz: scheduler: instanceName: clusteredScheduler #调度器实例名称 instanceId: AUTO #调度器实例编号自动生成 jobStore: class: org.quartz.impl.jdbcjobstore.JobStoreTX #持久化方式配置 driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate #持久化方式配置数据驱动，MySQL数据库 tablePrefix: qrtz_ #quartz相关数据表前缀名 isClustered: true #开启分布式部署 clusterCheckinInterval: 10000 #分布式节点有效性检查时间间隔，单位：毫秒 useProperties: false #配置是否使用 threadPool: class: org.quartz.simpl.SimpleThreadPool #线程池实现类 threadCount: 10 #执行最大并发线程数量 threadPriority: 5 #线程优先级 threadsInheritContextClassLoaderOfInitializingThread: true #配置是否启动自动加载数据库内的定时任务，默认true job-store-type: jdbc overwrite-existing-jobs: true Quartz SpringBoot使用​ DataCheckJob继承 Job重写execute方法，这里**与springboot2.x集成,需要注入DataMapper Bean,直接使用@Autowired强制注入,或者使用构造函数注入即可，其他低版本的则会出现bean注入不了的情况。需要自己实现AdaptableJobFactory注入bean ** 12345678910@Slf4jpublic class DataCheckJob implements QuartzJobBean { @Autowired DataMapper dataMapper; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { dataMapper.check(); }} 配置DataCheckJob与任务的触发器。 123456789101112@Configurationpublic class JobConfig { @Bean public JobDetail dataCheckJobDetail(){ return JobBuilder.newJob(DataCheckJob.class).storeDurably().build(); } @Bean public Trigger dataCheckTrigger(){ return TriggerBuilder.newTrigger().forJob(dataCheckJobDetail()).withIdentity(&quot;DataCheckJob&quot;) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0 37 11 ? * *&quot;)).build(); }} Quartz表说明qrtz_blob_triggers​ 自定义的triggers使用blog类型进行存储，非自定义的triggers不会存放在此表中，Quartz提供的triggers包括：CronTrigger，CalendarIntervalTrigger，DailyTimeIntervalTrigger以及SimpleTrigger，这几个trigger信息会保存在后面的几张表中； qrtz_cron_triggers存放CronTrigger类型的触发器实例 qrtz_simple_triggers存储SimpleTrigger qrtz_simprop_triggers存储CalendarIntervalTrigger和DailyTimeIntervalTrigger两种类型的触发器 qrtz_fired_triggers​ 存储已经触发的trigger相关信息，trigger随着时间的推移状态发生变化，直到最后trigger执行完成，从表中被删除。 相同的trigger和task，每触发一次都会创建一个实例；从刚被创建的ACQUIRED状态，到EXECUTING状态，最后执行完从数据库中删除。 qrtz_triggers存储定义的trigger，和qrtz_fired_triggers存放的不一样，不管trigger触发了多少次都只有一条记录，TRIGGER_STATE用来标识当前trigger的状态 qrtz_job_details存储jobDetails信息，相关信息在定义的时候指定。 qrtz_calendars​ Quartz为我们提供了日历的功能，可以自己定义一个时间段，可以控制触发器在这个时间段内触发或者不触发；现在提供6种类型：AnnualCalendar，CronCalendar，DailyCalendar，HolidayCalendar，MonthlyCalendar，WeeklyCalendar； qrtz_paused_trigger_grps存放暂停的触发器 qrtz_scheduler_state存储所有节点的scheduler，会定期检查scheduler是否失效，启动多个scheduler。 qrtz_locksQuartz提供的锁表，为多个节点调度提供分布式锁，实现分布式调度，默认有2个锁。 ​ /img/​ TRIGGER_ACCESS主要用在TRIGGER被调度的时候，保证只有一个节点去执行调度； Quartz表手动生成实际在使用Quartz过程中数据库中的表通常因为权限不能够自动生成，通常配置initialize-schema为never。 1spring.quartz.jdbc.initialize-schema=never|always 在quartz的jar的org/quartz/impl/jdbcjobstore包中有对应各种关系数据库的数据库生成脚本。有时候默认的quartz-sql对于最新的数据库，比如oracle19c不能很好兼容，需要我们自己修改对应SQL语句。","link":"/2023/09/25/springboot/SpringBoot%E9%9B%86%E6%88%90Quartz/"},{"title":"Springboot2.x基础教程：@Async开启异步任务","text":"在开发项目中通常我们有场景需要开启异步任务。比如在用户注册成功时，需要发放一些优惠券。此时为了不让这些额外的操作影响用户的注册流程，我们通常开启一个线程异步去执行发放优惠券逻辑。通常我们需要自己定义一个线程池，开启一个线程任务。在Springboot中对其进行了简化处理，自动配置一个 org.springframework.core.task.TaskExecutor类型任务线程池，当我们开启@EnableAsync注解时，在需要执行异步任务的方法添加@Async注解时，该方法自动会开启一个线程去执行。在讲解Springboot如何配置开启异步任务时，我们先简单说明下Java的线程池有关的基本知识。 线程池基本知识使用线程池场景通常高并发，任务执行时间短的业务创建线程的时间是T1,执行任务的时间是T2，销毁线程的时间是T3,当T1+T2的时间远远大于T2则可以采用线程池，线程池的作用核心在于复用线程，减少线程的创建与销毁的时间开销。方便的统计任务的执行信息，例如完成的任务数量。 Executor线程池的顶级接口Jdk1.5版本以后，便提供线程池供开发人员方便的创建自己的多线程任务。java.util.concurrent.Executor接口为线程池的顶级接口。该接口execute接收一个Runnable线程实例用来执行一个任务。 123public interface Executor { void execute(Runnable command);} ExecutorService接口详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public interface ExecutorService extends Executor { /**关闭线程池不会接收新的任务，内部正在跑的任务和队列里等待的任务，会执行完 */ void shutdown(); /** * 关闭线程池，不会接收新的任务 * 尝试将正在跑的任务interrupt中断 * 忽略队列里等待的任务 * 返回未执行的任务列表 */ List&lt;Runnable&gt; shutdownNow(); /** * 返回线程池是否被关闭 */ boolean isShutdown(); /** *线程池的任务线程是否被中断 */ boolean isTerminated(); /** *接收timeout和TimeUnit两个参数，用于设定超时时间及单位。 * 当等待超过设定时间时，会监测ExecutorService是否已经关闭，若关闭则返回true，否则返回false。和shutdown方法组合使用。 */ boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; /** * 提交任务会获取线程的执行结果 */ &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); /** * 提交任务会获取线程的T类型的执行结果 */ &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); /** * 提交任务 */ Future&lt;?&gt; submit(Runnable task); /** * 批量提交返回任务执行结果 */ &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; /** * 批量提交返回任务执行结果 *增加了超时时间控制，这里的超时时间是针对的所有tasks，而不是单个task的超时时间。 *如果超时，会取消没有执行完的所有任务，并抛出超时异常 */ &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; /** * 取得第一个方法的返回值,当第一个任务结束后，会调用interrupt方法中断其它任务 */ &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; /** * 取得第一个方法的返回值,当第一个任务结束后，会调用interrupt方法中断其它任务 * 任务执行超时抛出异常 */ &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;} ThreadPoolExecutor参数解析ThreadPoolExecutor 是用来处理异步任务的一个接口，可以将其理解成为一个线程池和一个任务队列，提交到 ExecutorService 对象的任务会被放入任务队或者直接被线程池中的线程执行并且ThreadPoolExecutor 支持通过调整构造参数来配置不同的任务处理策略。下面贴出ThreadPoolExecutor线程池构造函数代码: 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;} ThreadPoolExecutor每个入参含义：参数之间的关系： 从线程池中获取可用线程执行任务，如果没有可用线程则使用ThreadFactory创建新的线程，直到线程数达到corePoolSize限制 线程池线程数达到corePoolSize以后，新的任务将被放入队列，直到队列不能再容纳更多的任务 当队列不能再容纳更多的任务以后，会创建新的线程，直到线程数达到maxinumPoolSize限制 线程数达到maxinumPoolSize限制以后新任务会被拒绝执行，调用 RejectedExecutionHandler 进行处理[ RejectedExecutionHandler拒绝策略1、AbortPolicy：直接抛出异常，默认策略；2、CallerRunsPolicy：用调用者所在的线程来执行任务；3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；4、DiscardPolicy：直接丢弃任务； ThreadPoolExecutor使用要点 合理配置线程池的大小：如果是CPU密集的任务，线程池数量设置为CPU核心数+1即可，如果是IO密集任务，则CPU空闲较多，线程池数量设置为CPU核心数*2 任务队列：任务队列一般使用LinkedBlockingQueue指定大小，配合拒绝策略使用，默认是Integer.Max_VALUE容易内存溢出。 任务异常： 线程池中任务注意上加上try{}catch{}捕获异常，方便排查问题 SpringBoot线程池org.springframework.core.task.TaskExecutor为Spring异步线程池的接口类，其实质是java.util.concurrent.Executor。springboot2.3.x默认使用的线程池就是ThreadPoolTaskExecutor，可以通过TaskExecutionProperties进行简单的参数调整 SpringBoot定义自己的异步线程池1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@EnableAsync@Component@Slf4jpublic class AsyncConfig implements AsyncConfigurer { public TaskExecutor taskExecutor() { ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); // 设置核心线程数 executor.setCorePoolSize(8); // 设置最大线程数 executor.setMaxPoolSize(16); // 设置队列容量 executor.setQueueCapacity(50); // 设置线程活跃时间（秒） executor.setKeepAliveSeconds(60); //设置线程池中任务的等待时间，如果超过这个时候还没有销毁就强制销毁，以确保应用最后能够被关闭，而不是阻塞住 executor.setAwaitTerminationSeconds(60); // 设置默认线程名称 executor.setThreadNamePrefix(&quot;CodehomeAsyncTask-&quot;); // 设置拒绝策略 executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); // 等待所有任务结束后再关闭线程池 executor.setWaitForTasksToCompleteOnShutdown(true); executor.initialize(); return executor; } public Executor getAsyncExecutor() { return taskExecutor(); } public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new MyAsyncExceptionHandler(); } /** * 自定义异常处理类 */ class MyAsyncExceptionHandler implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException(Throwable throwable, Method method, Object... objects) { log.info(&quot;Exception message - &quot; + throwable.getMessage()); log.info(&quot;Method name - &quot; + method.getName()); for (Object param : objects) { log.info(&quot;Parameter value - &quot; + param); } } }} 两种使用方法1234567891011121314151617181920212223242526@Component@Slf4jpublic class UserServiceSyncTask { //不带返回值 @Async public void sendEmail(){ try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } log.info(Thread.currentThread().getName()); } //带返回值 @Async public Future&lt;String&gt; echo(String msg){ try { Thread.sleep(5000); return new AsyncResult&lt;String&gt;(Thread.currentThread().getName()+&quot;hello world !!!!&quot;); } catch (InterruptedException e) { // } return null; }} 千里之行，始于足下。这里是SpringBoot教程系列第十篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/24/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A@Async%E5%BC%80%E5%90%AF%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"},{"title":"Springboot2.x基础教程：@Enable原理","text":"上一篇springboot2.x基础教程：@Async开启异步任务我们使用了@EnableAsync注解来启用异步执行。SpringBoot框架中@Enable*注解有很多例如：@EnableAspectJAutoProxy、@EnableCaching、@EnableAutoConfiguration、@EnableSwagger2这一章讲讲它背后的原理。 几个典型的@Enable*注解下面贴出@EnableSwagger2、@EnableAsync、@EnableAspectJAutoProxy这三个注解，不难看出这三个注解都使用了@Import注解。@Import注解支持导入普通的java类,并将其声明成一个bean。实际@Enable注解就是通过@Import注解的能力实现Bean的注入springboot ioc容器，从而使某些配置生效。 @EnableScheduling123456@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Import({SchedulingConfiguration.class})@Documentedpublic @interface EnableScheduling {} @EnableAsync12345678910@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({AsyncConfigurationSelector.class})public @interface EnableAsync { Class&lt;? extends Annotation&gt; annotation() default Annotation.class; boolean proxyTargetClass() default false; AdviceMode mode() default AdviceMode.PROXY; int order() default 2147483647;} @EnableAspectJAutoProxy123456789@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Import({AspectJAutoProxyRegistrar.class})public @interface EnableAspectJAutoProxy { boolean proxyTargetClass() default false; boolean exposeProxy() default false;} @Import注解使用方式允许使用@Configuration注解的类@EnableScheduling注解的@Import导入的是SchedulingConfiguration类，我们看下该类的实现。我们可以看到该类使用了@Configuration、@Bean注解。@Import注解允许使用@Configuration注解的类注入容器中。 12345678910111213@Configuration@Role(2)public class SchedulingConfiguration { public SchedulingConfiguration() { } @Bean( name = {&quot;org.springframework.context.annotation.internalScheduledAnnotationProcessor&quot;} ) @Role(2) public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() { return new ScheduledAnnotationBeanPostProcessor(); }} 允许使用实现ImportSelectorj接口的类@EnableAsync注解的@Import导入的是AsyncConfigurationSelector类，我们看下该类实现。AsyncConfigurationSelector类实现了ImportSelector接口，重写了selectImports方法。@Import注解这里会把selectImports返回的全路径的类注入容器中。 123456789101112131415161718public class AsyncConfigurationSelector extends AdviceModeImportSelector&lt;EnableAsync&gt; { private static final String ASYNC_EXECUTION_ASPECT_CONFIGURATION_CLASS_NAME = &quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;; public AsyncConfigurationSelector() { } @Nullable public String[] selectImports(AdviceMode adviceMode) { switch(adviceMode) { case PROXY: return new String[]{ProxyAsyncConfiguration.class.getName()}; case ASPECTJ: return new String[]{&quot;org.springframework.scheduling.aspectj.AspectJAsyncConfiguration&quot;}; default: return null; } }} 允许是实现了ImportBeanDefinitionRegistrar接口的类@EnableAspectJAutoProxy注解的@Import导入的是AspectJAutoProxyRegistrar类，我们再看看该类实现。AspectJAutoProxyRegistrar实现了ImportBeanDefinitionRegistrar接口，ImportBeanDefinitionRegistrar的作用是在运行时自动添加Bean到已有的配置类，并在Spring容器启动时解析生成bean，通过重写方法registerBeanDefinitions。 123456789101112131415161718class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar { AspectJAutoProxyRegistrar() { } public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class); if (enableAspectJAutoProxy != null) { if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) { AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry); } if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) { AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry); } } }} @Import注解SpringBoot处理流程源码分析 Spring IOC容器初始化的时候会调用AbstractApplicationContext的refresh方法 在refresh里会调用各种BeanFactoryPostProcessor。ConfigurationClassPostProcessor的processConfigBeanDefinitions方法有对@Configuration、@Import等对注解的处理。 ConfigurationClassPostProcessor实际内部通过ConfigurationClassParser处理。 我们重点看看ConfigurationClassParser这个类对@Import处理。 ConfigurationClassParser类源码分析核心处理代码在ConfigurationClassParser的processImports方法中，实现了对于本文对于@Import三种使用方式的处理过程。 12345678910111213141516171819202122232425262728293031 private void processImports(ConfigurationClass configClass, ConfigurationClassParser.SourceClass currentSourceClass, Collection&lt;ConfigurationClassParser.SourceClass&gt; importCandidates, Predicate&lt;String&gt; exclusionFilter, boolean checkForCircularImports) {//....省略部分代码 ConfigurationClassParser.SourceClass candidate = (ConfigurationClassParser.SourceClass)var6.next(); Class candidateClass; if (candidate.isAssignable(ImportSelector.class)) { //对于处理ImportSelector注解处理 candidateClass = candidate.loadClass(); ImportSelector selector = (ImportSelector)ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector.class, this.environment, this.resourceLoader, this.registry); Predicate&lt;String&gt; selectorFilter = selector.getExclusionFilter(); if (selectorFilter != null) { exclusionFilter = exclusionFilter.or(selectorFilter); } if (selector instanceof DeferredImportSelector) { this.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector)selector); } else { String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata()); Collection&lt;ConfigurationClassParser.SourceClass&gt; importSourceClasses = this.asSourceClasses(importClassNames, exclusionFilter); this.processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, false); } } else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class)) { //对于ImportBeanDefinitionRegistrar接口处理 candidateClass = candidate.loadClass(); ImportBeanDefinitionRegistrar registrar = (ImportBeanDefinitionRegistrar)ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar.class, this.environment, this.resourceLoader, this.registry); configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata()); } else { this.importStack.registerImport(currentSourceClass.getMetadata(), candidate.getMetadata().getClassName()); //对于@Configuration注解处理 this.processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter); }//....省略部分代码 } 千里之行，始于足下。这里是SpringBoot教程系列第十一篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/24/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A@Enable%E5%8E%9F%E7%90%86/"},{"title":"Springboot2.x基础教程：@Scheduled开启定时任务及源码分析","text":"在项目开发过程中，我们经常需要执行具有周期性的任务，通过定时任务可以很好的帮助我们实现。常见的定时任务有JDK自带的TimeTask,ScheduledExecutorService，第三方的quartz框架，elastic-job等。今天要给大家介绍的是SpringBoot自带的定时任务框架，通过@Scheduled注解就能很方便的开启一个定时任务。Spring Schedule框架功能完善，简单易用。对于中小型项目需求，Spring Schedule是完全可以胜任的。 TimeTask,Spring-Schedule,Quartz对比 SpringBoot配置定时任务SpringBoot开启一个定时任务非常简单,在方法上加上@Scheduled注解跟配合@EnableScheduling注解开启就能够开启一个定时任务。 1234567891011121314151617181920212223@Component@EnableScheduling@Slf4jpublic class ScheduledTask { @Scheduled(cron = &quot;*/1 * * * * ?&quot;) public void cronTask1(){ log.info(&quot;CronTask-当方法的执行时间超过任务调度频率时，调度器会在下个周期执行&quot;); try { Thread.sleep(5100); } catch (InterruptedException e) { e.printStackTrace(); } } @Scheduled(fixedRate = 1000) public void cronTask2(){ log.info(&quot;fixedRate--固定频率执行，当前执行任务如果超时，调度器会在当前方法执行完成后立即执行&quot;); } @Scheduled(fixedDelay = 1000) public void cronTask3(){ log.info(&quot;fixedDelay---固定间隔执行，从上一次执行任务的结束时间开始算-------&quot;); }} 配置定时任务线程池在实际项目中，我们一个系统可能会定义多个定时任务。那么多个定时任务之间是可以相互独立且可以并行执行的。Spring Sheduld默认会创建一个单线程池执行定时任务。这样对于我们的多任务调度可能会是致命的，当多个任务并发（或需要在同一时间）执行时，任务调度器就会出现时间漂移，任务执行时间将不确定。所以我们通常给定时任务自定义配置一个线程池。 12345678910111213141516171819@EnableScheduling@Configurationpublic class ScheduledTaskConfig implements SchedulingConfigurer { @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) { scheduledTaskRegistrar.setScheduler(taskExecutor()); } public ThreadPoolTaskScheduler taskExecutor() { ThreadPoolTaskScheduler scheduler=new ThreadPoolTaskScheduler(); // 设置核心线程数 scheduler.setPoolSize(8); // 设置默认线程名称 scheduler.setThreadNamePrefix(&quot;CodehomeScheduledTask-&quot;); scheduler.setWaitForTasksToCompleteOnShutdown(true); scheduler.initialize(); return scheduler; }} 定时任务源码解析SpringBoot加上@EnableScheduling注解配合@Scheduled就能生成定时任务，背后的源码带大家分析一遍。 扫描定时任务@EnableScheduling注解引入了SchedulingConfiguration类 1234@Import({SchedulingConfiguration.class})public @interface EnableScheduling {} SchedulingConfiguration又引入了ScheduledAnnotationBeanPostProcessor类，核心的流程在该类中。 123456789@Configurationpublic class SchedulingConfiguration { @Bean( name = {&quot;org.springframework.context.annotation.internalScheduledAnnotationProcessor&quot;} ) public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() { return new ScheduledAnnotationBeanPostProcessor(); }} 该类继承了BeanPostProcessor接口是Spring IOC容器给我们提供的一个扩展接口。 123456public interface BeanPostProcessor { //bean初始化方法调用前被调用 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; //bean初始化方法调用后被调用 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;} 因此在该类初始化bean后执行postProcessAfterInitialization方法,扫描容器中Bean带有@scheduled注解的方法，并通过processScheduled解析。processScheduled会解析前面提到的cron、fixedDelay、fixedRate等属性，创建不同的类型的Task，加入scheduledTasks变量中。 触发定时任务 在容器发出ContextRefreshedEvent事件时，事件监听方法会调用finishRegistration()方法 finishRegistration()会调用registrar.afterPropertiesSet()方法 afterPropertiesSet()方法调用scheduleTasks(); scheduleTasks方法依次调用各个定时任务，这里也验证了不配置线程池，默认是单线程执行。以上就是对springboot定时任务简单的分析，看完后发现还是很简单的。我们学习springboot源码学习的是优秀的设计方法，通过理解、模仿、从而创新，自己的编程功底才能进一步提升。千里之行，始于足下。这里是SpringBoot教程系列第十三篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/24/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A@Scheduled%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"title":"Springboot2.x基础教程：SpringCache缓存抽象详解与Ehcache、Redis缓存配置实战","text":"在计算机发展史中一台计算机只需要外部存储器就能运行，但是在实际中磁盘的读取数据的速度往往跟不上CPU的运算速度，因此引入的内存作为CPU和外部存储器之间的缓冲区域。在项目开发过程数据库数据的查询速度远远比不上数据在内存中的访问速度，因此我们通常使用缓存来提高热点数据的访问速度，缓存可谓是计算机科学中最伟大的发明。 缓存基本知识缓存命中率12命中率=从缓存中读取的速度/总读取次数(从缓存读取次数+从慢速设备读取次数)Miss率=没有从缓存中读取的速度/总读取次数(从缓存读取次数+从慢速设备读取次数) 这是一个缓存非常重要的一个性能指标，往往命中率越高表示缓存作用越大 缓存策略移除策略，即如果缓存满了，如何从缓存中移除数据的策略 FIFO(First in First Out):先进先出算法，即先放入缓存的数据先被移除 LRU(Least Recently used)：最久未使用的数据优先被有限移除 LFU(Least Frequently used): 最少被使用的数据有限被移除 缓存设置参数 TTL(Time To live): 存活期，即从缓存中创建时间点开始直到它到期的一个时间段（不管在这个时间段内有没有访问都将过期） TTI(Time To Idle): 空闲期，即一个数据多久没被访问将从缓存中移除的时间。 最多被缓存的元素 Spring注解缓存Spring 3.1之后，引入了注解缓存技术，其本质上不是一个具体的缓存实现方案，而是一个对缓存使用的抽象，通过在既有代码中添加少量自定义的各种annotation，即能够达到使用缓存对象和缓存方法的返回对象的效果。Spring的缓存技术具备相当的灵活性，不仅能够使用SpEL（Spring Expression Language）来定义缓存的key和各种condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存集成。其特点总结如下： 少量的配置annotation注释即可使得既有代码支持缓存； 支持开箱即用，不用安装和部署额外的第三方组件即可使用缓存； 支持Spring Express Language（SpEL），能使用对象的任何属性或者方法来定义缓存的key和使用规则条件； 支持自定义key和自定义缓存管理者，具有相当的灵活性和可扩展性。 缓存相关注解 注解 说明 配置参数 @Cacheable 根据方法的请求参数对其结果进行缓存 value：缓存的名称；key：缓存的 key，可以为空，也可按照SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存 @CachePut 根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用 value：缓存的名称；key：缓存的 key，可以为空，也可按照SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存 @CacheEvict 够根据一定的条件对缓存进行清空 value：缓存的名称；key：缓存的 key，可以为空，也可按照SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合；condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存； allEntries：是否清空所有缓存内容，默认为 false，如果指定为 true，则方法调用后将立即清空所有缓存； beforeInvocation：是否在方法执行前就清空，默认为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，默认情况下，如果方法执行抛出异常，则不会清空缓存 集成Ehcache缓存EhCache是一个比较成熟的Java缓存框架，最早从hibernate发展而来， 是进程中的缓存系统，它提供了用内存，磁盘文件存储，以及分布式存储方式等多种灵活的cache管理方案，快速简单。Springboot对ehcache的使用非常支持，所以在Springboot中只需做些配置就可使用，且使用方式也简易。 引入依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt;&lt;/dependency&gt; 配置Ehcache缓存配置1234567891011121314151617181920&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!--磁盘路径，内存满了存放位置--&gt; &lt;diskStore path=&quot;caches&quot;/&gt; &lt;cache name=&quot;users&quot; &lt;!-- 最多存储的元素--&gt; maxElementsInMemory=&quot;10000&quot; &lt;!--缓存中对象是否永久有效--&gt; eternal=&quot;false&quot; &lt;!--缓存数据在失效前的允许闲置时间(单位:秒)，仅当eternal=false时使用,默认值是0表示可闲置时间无穷大,若超过这个时间没有访问此Cache中的某个元素,那么此元素将被从Cache中清除--&gt; timeToIdleSeconds=&quot;120&quot; &lt;!--缓存数据的总的存活时间（单位：秒），仅当eternal=false时使用，从创建开始计时，失效结束。--&gt; timeToLiveSeconds=&quot;120&quot; &lt;!--磁盘缓存中最多可以存放的元素数量,0表示无穷大--&gt; maxElementsOnDisk=&quot;10000000&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; &lt;!--缓存策略--&gt; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;persistence strategy=&quot;localTempSwap&quot;/&gt; &lt;/cache&gt;&lt;/ehcache&gt; applicatin.yml配置ehcache地址，在springboot启动类加上@EnableCaching注解 12345spring: cache: ehcache: config: classpath:ehcache.xml type: ehcache 配置Redis缓存配置引入依赖123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt; Redis配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117@Configuration@EnableCaching//开启缓存public class RedisConfig extends CachingConfigurerSupport { private final static Logger log= LoggerFactory.getLogger(RedisConfig.class); @Bean public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { return new RedisCacheManager( RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory), this.getRedisCacheConfigurationWithTtl(60*60*24), // 默认策略，未配置的 key 会使用这个 this.getRedisCacheConfigurationMap() // 指定 key 策略 ); } private Map&lt;String, RedisCacheConfiguration&gt; getRedisCacheConfigurationMap() { Map&lt;String, RedisCacheConfiguration&gt; redisCacheConfigurationMap = new HashMap&lt;&gt;(); //可以进行过期时间配置 redisCacheConfigurationMap.put(&quot;24h&quot;, this.getRedisCacheConfigurationWithTtl(60*60*24)); redisCacheConfigurationMap.put(&quot;30d&quot;, this.getRedisCacheConfigurationWithTtl(60*60*24*30)); return redisCacheConfigurationMap; } private RedisCacheConfiguration getRedisCacheConfigurationWithTtl(Integer seconds) { Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig(); redisCacheConfiguration = redisCacheConfiguration.serializeValuesWith( RedisSerializationContext .SerializationPair .fromSerializer(jackson2JsonRedisSerializer) ).entryTtl(Duration.ofSeconds(seconds)); //自定义前缀 默认为中间两个： redisCacheConfiguration = redisCacheConfiguration.computePrefixWith(myKeyPrefix()); return redisCacheConfiguration; } /** * 缓存前缀（追加一个冒号 : ） * @return */ private CacheKeyPrefix myKeyPrefix(){ return (name) -&gt; { return name +&quot;:&quot;; }; } /** * 生成Key规则 * @return */ @Bean public KeyGenerator wiselyKeyGenerator() { return new KeyGenerator() { @Override public Object generate(Object target, Method method, Object... params) { StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(&quot;.&quot; + method.getName()); if(params==null||params.length==0||params[0]==null){ return null; } String join = String.join(&quot;&amp;&quot;, Arrays.stream(params).map(Object::toString).collect(Collectors.toList())); String format = String.format(&quot;%s{%s}&quot;, sb.toString(), join); //log.info(&quot;缓存key：&quot; + format); return format; } }; } @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory factory) { RedisTemplate&lt;String, String&gt; redisTemplate = new RedisTemplate&lt;String, String&gt;(); redisTemplate.setConnectionFactory(factory); return redisTemplate; } /** * 缓存异常处理 * @return */ @Bean @Override public CacheErrorHandler errorHandler() { CacheErrorHandler cacheErrorHandler = new CacheErrorHandler() { @Override public void handleCacheGetError(RuntimeException e, Cache cache, Object key) { log.info(&quot;redis缓存获取异常：&quot;+ key); } @Override public void handleCachePutError(RuntimeException e, Cache cache, Object key, Object value) { log.info(&quot;redis缓存添加异常：&quot;+ key); } @Override public void handleCacheEvictError(RuntimeException e, Cache cache, Object key) { log.info(&quot;redis缓存删除异常：&quot;+ key); } @Override public void handleCacheClearError(RuntimeException e, Cache cache) { log.info(&quot;redis缓存清理异常&quot;); } }; return cacheErrorHandler; }} applicatin.yml配置Redis连接信息 12345678910spring: redis: timeout: 5000ms lettuce: pool: max-active: 5 max-wait: -1 max-idle: 10 cache: type: redis 缓存注解使用举例对用户的查询、新增、删除使用缓存，以及更新缓存 12345678public interface UserService { @Cacheable(value = &quot;users&quot;,key = &quot;#userDO.id&quot;) List&lt;UserDO&gt; queryUsers(UserDO userDO); @CachePut(value = &quot;users&quot;,key =&quot;#userDO.id&quot; ) void saveUser(UserDO userDO); @CacheEvict(value = &quot;users&quot;,key = &quot;#userDO.id&quot;) void removeUser(UserDO userDO);} 千里之行，始于足下。这里是SpringBoot教程系列第十五篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/25/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9ASpringCache%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1%E8%AF%A6%E8%A7%A3%E4%B8%8EEhcache%E3%80%81Redis%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE%E5%AE%9E%E6%88%98/"},{"title":"Springboot2.x基础教程：Swagger详解给你的接口加上文档说明","text":"相信无论是前端还是后端开发，都或多或少地被接口文档折磨过。前端经常抱怨后端给的接口文档与实际情况不一致。后端又觉得编写及维护接口文档会耗费不少精力，经常来不及更新。其实无论是前端调用后端，还是后端调用后端，都期望有一个好的接口文档。SpringBoot集成Swagger能够通过很简单的注解把接口描述清楚，生成可视化文档页面。原生的Swagger-ui界面很粗糙，这里用knife4j-spring-ui替代。 一个好的HTTP接口文档描述 写清楚接口的请求路径: QueryPath: /user/login 写清楚接口的请求方法类型： GET/POST/DELETE/PUT 写清楚接口的业务含义,使用场景 写清楚接口的入参：参数描述、参数类型、参数结构、参数是否必传 写清楚接口的返回类型：返回的数据结构，异常状况 SpringBoot集成Swagger项目引入依赖123456789101112131415&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;knife4j-spring-ui&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; SpringBoot关于Swagger配置把此Swagger配置粘入项目即可 1234567891011121314151617181920212223242526272829303132333435@EnableSwagger2@Configurationpublic class SwaggerConfig implements WebMvcConfigurer { @Bean public Docket createRestApi() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() //这里改成自己的接口包名 .apis(RequestHandlerSelectors.basePackage(&quot;vip.codehome.springboot.tutorials.controller&quot;)) .paths(PathSelectors.any()) .build(); } private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(&quot;SpringBoot教程接口文档&quot;)//标题 .description(&quot;使用swagger文档管理接口&quot;)//描述 .contact(new Contact(&quot;codehome&quot;, &quot;&quot;, &quot;dsyslove@163.com&quot;))//作者信息 .version(&quot;1.0.0&quot;)//版本号 .build(); } //解决doc.html，swagger-ui.html 404问题 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(&quot;/**&quot;).addResourceLocations( &quot;classpath:/static/&quot;); registry.addResourceHandler(&quot;swagger-ui.html&quot;).addResourceLocations( &quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;doc.html&quot;).addResourceLocations( &quot;classpath:/META-INF/resources/&quot;); registry.addResourceHandler(&quot;/webjars/**&quot;).addResourceLocations( &quot;classpath:/META-INF/resources/webjars/&quot;); }} Swagger的具体使用各个注解的作用 @Api 放在类上介绍类的作用 @ApiOperation 放在方法上介绍方法的作用 @ApiImplicitParam介绍入参说明 @ApiResponse介绍返回状态 @ApiModel、@ApiModelProperty介绍入参是对象，返回是对象字段说明 代码示例12345678910111213141516171819202122232425262728293031323334@RestController@Api(tags = &quot;Swagger注解测试类&quot;)public class SwaggerUserController { @ApiOperation(value = &quot;这是一个echo接口&quot;) @ApiImplicitParams({ @ApiImplicitParam(name = &quot;msg&quot;,value = &quot;请求的msg参数&quot;,required = true,paramType = &quot;query&quot;), @ApiImplicitParam(name = &quot;token&quot;,value = &quot;请求的token&quot;,required = false,paramType =&quot;header&quot; ) }) @ApiResponses({ @ApiResponse(code=200,message = &quot;请求成功&quot;), @ApiResponse(code=400,message=&quot;请求无权限&quot;) }) @GetMapping(&quot;/echo&quot;) public String echo(String msg,@RequestHeader(name = &quot;token&quot;) String token){ return msg; } @PostMapping(&quot;/login&quot;) public R&lt;UserInfoVO&gt; login(@RequestBody LoginDTO loginDTO){ UserInfoVO userInfoVO=new UserInfoVO(); userInfoVO.setNickname(&quot;编程之家&quot;); userInfoVO.setToken(&quot;xxx&quot;); return R.ok(userInfoVO); }}@Data@ApiModelpublic class LoginDTO { @ApiModelProperty(value = &quot;用户账号或者邮箱&quot;) String account; @ApiModelProperty(value = &quot;用户密码&quot;) String passwd; @ApiModelProperty(value = &quot;用户密码&quot;) String verifyCode;} 接口文档效果这里访问的是http://localhost:8080/doc.html,knife4j-spring-ui还有相比原生还有更多强大的功能，大家自行发现。千里之行，始于足下。这里是SpringBoot教程系列第二篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9ASwagger%E8%AF%A6%E8%A7%A3%E7%BB%99%E4%BD%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%8A%A0%E4%B8%8A%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E/"},{"title":"Springboot2.x基础教程：jsr303接口参数校验,结合统一异常拦截","text":"JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。JSR-303 是JAVA EE 6 中的一项子规范，叫做Bean Validation，Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。如果想了解更多有关 Hibernate Validator 的信息，请查看 http://www.hibernate.org/subprojects/validator.htmlSpringBoot项目开发的后端接口，常常会对参数是否为空、参数长度进行基本的校验，这里SpringBoot能够很方便的集成JSR303，通过注解很方便的验证接口参数，并且可以自定义验证规则。 JSR303注解介绍JSR303自带约束 Hibernate Validator附加的约束 SpringBoot项目集成项目引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;&lt;/dependency&gt; Hibernate Validator介绍Hibernate Validator的校验模式有两种情况 快速失败（验证失败一个，快速返回错误信息） 普通模式（默认，会校验完所有的属性，然后返回所有的验证失败信息）我们一般使用第一种，SpringBoot需要开启配置123456789101112131415/** * 配置Jsr303 hibernate validator快速失败模式 */@Configurationpublic class Jsr303Config { @Bean public Validator validator(){ ValidatorFactory validatorFactory = Validation .byProvider( HibernateValidator.class ) .configure() .failFast( true ) .buildValidatorFactory(); return validatorFactory.getValidator(); }} 基本使用在方法上使用@Valid注解开启验证，使用BindingResult接收验证结果 123456789101112131415161718192021@Datapublic class LoginDTO { @Size(min = 8,message = &quot;账号长度大于8&quot;) String account; @NotBlank(message = &quot;密码不能为空&quot;) String passwd;} @PostMapping(&quot;/logon&quot;) public R logon(@Valid LoginDTO loginDTO, BindingResult result){ check(result); return R.ok(&quot;&quot;); } public static void check(BindingResult result){ StringBuffer sb=new StringBuffer(); if(result.hasErrors()){ for (ObjectError error : result.getAllErrors()) { sb.append(error.getDefaultMessage()); } ExUtil.throwBusException(sb.toString()); } } Jsr303配合统一异常使用在项目中我通常要定义属于业务的统一异常类，这里验证失败后组装自定义的验证信息，抛出自定义的BusinessException异常。 12345678910111213141516public class BusinessException extends RuntimeException { private static final long serialVersionUID = 1L; private int code = ApiCommonCodeEnum.FAIL.getCode(); public BusinessException(String message) { super(message); } //防止篇幅过长省略其他代码}//异常工具类public class ExUtil { public static void throwBusException(String msg){ throw new BusinessException(msg); } //......} 然后被统一异常拦截，返回前面定义的R接口,失败信息包含在msg字段中。贴出统一异常拦截部分代码 123456789101112131415161718192021222324252627282930313233343536@Component@Slf4jpublic class ExceptionResolver implements HandlerExceptionResolver { @Override public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception ex) { if(ex instanceof BusinessException){ R result= R.fill(((BusinessException) ex).getCode(),null,ex.getMessage()); outputJSON(httpServletResponse, Charsets.UTF_8.toString(), JsonUtil.toJson(result)); return null; }else { R result=R.failed(ex.getMessage()); outputJSON(httpServletResponse, Charsets.UTF_8.toString(), JsonUtil.toJson(result)); return null; } } private void outputJSON(HttpServletResponse response, String charset, String jsonStr) { PrintWriter out = null; try { if (response != null) { response.setCharacterEncoding(charset); response.setContentType(&quot;text/html;charset=&quot; + charset); response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); out = response.getWriter(); out.print(jsonStr); } } catch (Exception e) { log.error(ExUtil.getSimpleMessage(e)); } finally { if (out != null) { out.close(); } } }} 接口测试效果千里之行，始于足下。这里是SpringBoot教程系列第四篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9Ajsr303%E6%8E%A5%E5%8F%A3%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C,%E7%BB%93%E5%90%88%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/"},{"title":"Springboot2.x基础教程：springmvc参数绑定注解今天彻底搞清楚","text":"在编写SpringBoot项目中我们通常在Controller层使用@RequestParam、@RequestBody等注解接收前端请求参数。我们应该怎么使用各种注解，这片文章带大家把springmvc参数绑定使用彻底搞清楚。 Http请求报文HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，请求报文包含： 请求方法 在Springboot中请求方法最常用的是GET或者POST方法，其他的HEAD、PUT一般不会使用 GET通常用于查询某个资源，POST通常用于新增、更新、删除资源操作。 GET一般利用URL传递参数，POST利用请求体。 URL的一般浏览器设定最大长度为1k,POST利用的请求体的无数据限制 在Http协议中没有规定GET不能利用请求体发送数据，实际上我们是可以这样做的。但是因为有些服务器实现可能直接把GET的请求体内容忽略掉，所以一般我们不会这样使用 请求URLURL,全称是UniformResourceLocator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。 1scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] 1http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument 请求头部请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔。请求头部通知服务器有关于客户端请求的信息。 1234567891011:authority: www.cnblogs.com:method: GETcontent-type: application/json; charset=utf-8cookie: _ga=GA1.2.1704734765.1586779730; _gid=GA1.2.846324607.1598838524pragma: no-cachereferer: https://www.cnblogs.com/sec-fetch-dest: emptysec-fetch-mode: corssec-fetch-site: same-originuser-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36x-requested-with: XMLHttpRequest 请求数据协议规定post提交的数据，必须包含在消息主体中entity-body中，但是协议并没有规定数据使用什么编码方式。开发者可以自己决定消息主体的格式,服务端会根据content-type字段来获取参数是怎么编码的，然后对应去解码 常见的ContentType1、application/x-www-form-urlencoded浏览器的原生form表单提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key和val都进行了URL转码 2、multipart/form-data常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctype 等于这个值。 3、application/json消息主体是序列化后的 JSON 字符串 4、text/xml使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范 SpringMVC参数绑定@PathVariable注解详解@PathVariable 是用来获得请求url中的动态参数的，可以将URL中的变量映射到功能处理方法的参数上，其中URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 12345@GetMapping(&quot;/user/{id}&quot;)@ResponseBodypublic R userInfo(@PathVariable(&quot;id&quot;)String id){ return R.ok(id);} @RequestHeader注解详解@RequestHeader 注解，可以把Request请求header部分的值绑定到方法的参数上。 12345@GetMapping(&quot;/useragent&quot;)@ResponseBodypublic R getHeader(@RequestHeader(&quot;User-Agent&quot;)String userAgent){ //...省略} @CookieValue注解详解@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上。 12345@GetMapping(&quot;/cookie&quot;)@ResponseBodypublic R getCookie(@CookieValue(&quot;token&quot;)String token){ //...省略} @RequestParam详解@RequestParam注解用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式为get或post。@RequestParam注解实质是将Request.getParameter()中的Key-Value参数Map利用Spring的转化机制ConversionService配置，转化成参数接收对象或字段，RequestParam可以获取的到get方式中queryString的值，和post方式中body data的值。 12345@RequestMapping(&quot;/reqparam&quot;)@ResponseBodypublic R requsetParam(@RequestParam Map&lt;String,Object&gt; params) { return R.ok(params);} get请求@RequestParam获取到了url上的参数： post请求@RequestParam获取到了url上的参数和请求实体的参数: @RequestParam同样可以用来处理Content-Type：为form/data的内容，通常用于文件上传123456@RequestMapping(&quot;/upload&quot;)@ResponseBodypublic R requsetParam(@RequestParam(&quot;files&quot;) MultipartFile file,@RequestParam Map&lt;String,Object&gt; params) { params.put(&quot;files&quot;,file.getOriginalFilename()); return R.ok(params);} @RequestBody详解@RequestBody注解用来处理HttpEntity（请求体）传递过来的数据，一般用来处理非Content-Type: application/x-www-form-urlencoded编码格式的数据 @RequestBody获取Json数据12345@RequestMapping(&quot;/json&quot;)@ResponseBodypublic R json(@RequestBody UserDO userDO){ return R.ok(userDO);} @RequestBody获取xml数据12345@RequestMapping(value = &quot;/xml&quot;,consumes = &quot;application/xml&quot;,produces =&quot;application/xml&quot;,method = RequestMethod.POST)@ResponseBodypublic UserDO xml(@RequestBody UserDO userDO){ return userDO;} 千里之行，始于足下。这里是SpringBoot教程系列第十六篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9Aspringmvc%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%E6%B3%A8%E8%A7%A3%E4%BB%8A%E5%A4%A9%E5%BD%BB%E5%BA%95%E6%90%9E%E6%B8%85%E6%A5%9A/"},{"title":"Springboot2.x基础教程：动手制作一个starter包","text":"上一篇博客介绍了springboot自动装配的原理。springboot本身有丰富的spring-boot-starter-xx集成组件，这一篇趁热打铁加深理解，我们利用springboot自动装配的机制，制作一个属于自己的starter包。 制作一个starter包思路​ 这一篇博客我制作一个上传图片第三方图床的starter，集成常见的第三方图床sm.ms、imgur、github图床等。 ​ 本教程不会具体的讲解图床上传相关的代码，而是主要分析封装此starter的思路。 首先安装springboot第三方的starter规范命名：xx-spring-boot-starter,我们项目取名为imghost-spring-boot-starter。 对于图床相关的配置项，我们同样准备建立一个ImgHostProperties配置类存放。 同样我们也需要一个ImgHostAutoConfiguration,并且加上条件注解在某些情况下才会注入我们的工具类到IOC容器中。 按照规范在我们项目的META-INF/spring.factories文件下，指定我们starter的自动装配类。 项目结构一览 Starter开发实例引入必要的依赖​ 这里主要引入spring-boot-starter包，spring-boot-configuration-processor其他依赖主要为上传到第三方图床发送Http请求依赖包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;vip.codehome&lt;/groupId&gt; &lt;artifactId&gt;imghost-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.14.9&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/spring.factories&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--把注释源码也打入基础包中--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;jar-no-fork&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 定义一个图床参数上传的配置类​ 上传到SM.MS的API需要上传的token，在sm.ms网站注册获取个人的私钥，后面如果上传到imgur同样可以在此类中加入对应的配置类。 123456789@Data@ConfigurationProperties(prefix = &quot;imghost&quot;)public class ImgHostProperties { SMMS smms; @Data public static class SMMS{ String token; }} 定义上传服务AutoConfiguration类当imghost.smms.token使用者配置时，我们生成一个SMMSImgHostService的图床上传服务类。 1234567891011121314151617@Configuration@EnableConfigurationProperties(ImgHostProperties.class)@ConditionalOnProperty(prefix = &quot;imghost&quot;,name = &quot;enabled&quot;,havingValue = &quot;true&quot;,matchIfMissing = true)public class ImgHostAutoConfiguration { private final ImgHostProperties imgHostProperties; public ImgHostAutoConfiguration(ImgHostProperties imgHostProperties) { this.imgHostProperties = imgHostProperties; } @ConditionalOnMissingBean @ConditionalOnProperty(prefix=&quot;imghost.smms&quot;,name=&quot;token&quot;) @Bean public SMMSImgHostService imgHostService() { return new SMMSImgHostService(imgHostProperties); }} 编写spring.factories​ 最后在项目的src/main/resource上加入META-INF/spring.factories中引入我们自定义的ImgHostAutoConfiguration配置类。 1org.springframework.boot.autoconfigure.EnableAutoConfiguration=vip.codehome.imghost.ImgHostAutoConfiguration 如何使用 在使用的项目中引入我们的imghost-spring-boot-starter。 12345&lt;dependency&gt; &lt;groupId&gt;vip.codehome&lt;/groupId&gt; &lt;artifactId&gt;imghost-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 在springboot项目中加入如下配置 项目使用 12345@AutowiredSMMSImgHostService smms;public void upload() { System.out.println(smms.upload(newFile(&quot;D:\\\\test.jpg&quot;)));} 总结​ 千里之行，始于足下。这里是SpringBoot教程系列第十八篇。以上就是我们自己动手制作一个starter包的全过程，是不是很简单。此项目在github可下载源码 ​ 当前只是实现了上传到SM.MS图床，后期会逐渐迭代一个上传到sm.ms,imgur，github各种图床的通用工具类，敬请期待。如果觉得不错，点赞、评论、关注三连击","link":"/2023/09/25/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E5%8A%A8%E6%89%8B%E5%88%B6%E4%BD%9C%E4%B8%80%E4%B8%AAstarter%E5%8C%85/"},{"title":"Springboot2.x基础教程：单元测试","text":"单元测试用于测试单个代码组件，并确保代码按预期方式工作。单元测试由开发人员编写和执行。大多数情况下，会使用JUnit或TestNG这样的测试框架。测试用例通常在方法级别编写，并通过自动化执行。Spring Boot提供了一些注解和工具去帮助开发者测试他们的应用。在讲springboot单元测试之前，先简单介绍下软件测试的类型(从开发角度来说)，跟如何写好一个单元测试。 软件测试类型 单元测试：用于测试单个代码组件，并确保代码按预期方式工作。单元测试由开发人员编写和执行。 集成测试: 检查整个系统是否工作正常。集成测试也是由开发人员完成的，但它不是测试单个组件，而是旨在跨组件进行测试。系统由许多单独的组件组成，如代码、数据库、Web服务器等。集成测试能够发现组件的连接、网络访问、数据库问题等问题。 功能测试: 通过将给定输入的结果与规范进行比较来检查每个特性是否正确实现。这个阶段通常由公司专门的测试团队来负责。 验收测试：验收测试是保证软件的准备就绪，按照项目合同、任务书、双方约定的验收依据文档，向软件的购买者展示该软件的原始的需求。 单元测试要点 测试的粒度是方法级的。 测试的用例的结果应该是稳定的。 测试的用例应该尽量少写逻辑或者不写测试逻辑。 测试用例应该有很高的覆盖率，把基本的输入输出覆盖,一些边界也要覆盖到。 使用断言而不是输出打印的语句。 单元测试用例应该有个好名字，例如test_MethodName() SpringBoot集成单元测试引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 依赖关系 JUnit — The de-facto standard for unit testing Java applications. Spring Test &amp; Spring Boot Test — Utilities and integration test support for Spring Boot applications. AssertJ — A fluent assertion library. Hamcrest — A library of matcher objects (also known as constraints or predicates). Mockito — A Java mocking framework. JsonPath — XPath for JSON 常用注解说明 @RunWith(SpringRunner.class)JUnit运行使用Spring的测试支持。SpringRunner是SpringJUnit4ClassRunner的新名字，这样做的目的仅仅是为了让名字看起来更简单一点。 @SpringBootTest用于Spring Boot应用测试，它默认会根据包名逐级往上找，一直找到Spring Boot主程序，通过类注解是否包含@SpringBootApplication来判断是否主程序，并在测试的时候启动该类来创建Spring上下文环境。 @BeforeClass针对所有测试，只执行一次，且必须为static void @BeforeEach初始化方法，执行当前测试类的每个测试方法前执行 @Test测试方法，在这里可以测试期望异常和超时时间 @AfterEach释放资源，执行当前测试类的每个测试方法后执行 @AfterClass针对所有测试，只执行一次，且必须为static void @Ignore忽略的测试方法 断言常见使用方法 assertNotNull(“message”,A) //判断A不为空 assertFalse(“message”,A) //判断条件A不为真 assertTure(“message”,A) //判断条件A为真 assertEquals(“message”,A,B) // 判断A.equals(B) assertSame(“message”,A,B) //判断A==B 测试方法12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class UserRepositoryTest { @Autowired UserRepository userRepository; @Test @Ignore public void testFindAll(){ Page&lt;UserDO&gt; userDOS= userRepository.findAll(PageRequest.of(1,10)); Assert.assertNotNull(userDOS.getContent()); } @Test(expected = RuntimeException.class) public void testNullPointerException(){ throw new RuntimeException(); }} 测试API接口 MockMvcRequestBuilders构造请求的路径，请求的参数等信息 andExpect添加断言判断结果是否达到预期 andDo添加结果处理器，比如示例中的打印 andReturn返回验证成功后的MvcResult,用于自定义验证/下一步的异步处理。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566@RunWith(SpringRunner.class)@SpringBootTest@AutoConfigureMockMvcclass UserControllerTest { @Autowired MockMvc mockMvc; UserDO userDO; MultiValueMap&lt;String,String&gt; params; @BeforeEach public void setUp()throws Exception{ userDO=new UserDO(); userDO.setPasswd(&quot;123456&quot;); params=new LinkedMultiValueMap&lt;&gt;(); params.add(&quot;name&quot;,&quot;codehome&quot;); } //测试get接口 @Test public void queryUser() throws Exception { String result= mockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/query&quot;) .contentType(MediaType.APPLICATION_FORM_URLENCODED) .params(params) ).andExpect(MockMvcResultMatchers.status().is2xxSuccessful()) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse() .getContentAsString(); Assert.assertEquals(&quot;调用成功&quot;,&quot;codehome&quot;,result); } //测试post接口 @Test void addUser() throws Exception { mockMvc.perform(MockMvcRequestBuilders.post(&quot;/user/add&quot;) .contentType(MediaType.APPLICATION_JSON) .content(JsonUtil.toJson(userDO)) .accept(MediaType.APPLICATION_JSON) ).andExpect(MockMvcResultMatchers.status().is2xxSuccessful()) .andDo(MockMvcResultHandlers.print()) .andExpect(MockMvcResultMatchers.jsonPath(&quot;$.data.passwd&quot;).value(&quot;123456&quot;)); } //测试cookie @Test void testCookie()throws Exception{ String token= mockMvc.perform(MockMvcRequestBuilders.get(&quot;/user/cookie&quot;) .cookie(new Cookie(&quot;token&quot;,&quot;123456&quot;))) .andDo(MockMvcResultHandlers.print()) .andReturn().getResponse() .getContentAsString(); Assert.assertEquals(&quot;token从cookie中获取成功&quot;,&quot;123456&quot;,token); }}//测试的接口类@RestController@RequestMapping(&quot;/user&quot;)public class UserController { @GetMapping(&quot;/query&quot;) public String queryUser(String name){ return name; } @PostMapping(&quot;/add&quot;) public R addUser(@RequestBody UserDO userDO){ return R.ok(userDO); } @GetMapping(&quot;/cookie&quot;) public String testCookie(@CookieValue(&quot;token&quot;) String token){ return token; }} 千里之行，始于足下。这里是SpringBoot教程系列第七篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"Springboot2.x基础教程：快速开始","text":"这里是SpringBoot2.x教程第一篇开始，开发工具为idea+JDK1.8+Maven，学习前提大家也提前安装配置好开发环境Spring官方提供了非常方便的工具Spring Initializr来帮助我们创建Spring Boot应用第一次带领大家使用Idea开发工具快速创建一个SpringBoot Web项目 Idea新建工程选择Spring Initializr 项目使用Maven构建，指定Jdk版本为1.8，修改项目GroupId，ArtifactId 选择SpringBoot版本，这里选择当前最新的2.3.2，勾选SpringWeb依赖 至此下一步打开项目,下载好项目依赖，就可以正常启动SpringBoot项目 千里之行，始于足下。不要嫌弃一开始很简单，后面慢慢在此项目基础上介绍SpringBoot的方方面面，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"},{"title":"Springboot2.x基础教程：接口实现统一格式返回","text":"在SpringBoot项目中经常会涉及到前后端数据的交互，目前比较流行的是基于 json 格式的数据交互。但是 json 只是消息的格式，其中的内容还需要我们自行设计。不管是 HTTP 接口还是 RPC 接口保持返回值格式统一很重要，这将大大降低 前后端联调的成本。 定义的接口具体格式12345678{ #返回状态码 &quot;code&quot;:integer类型, #返回信息描述 &quot;msg&quot;:string, #返回值 &quot;data&quot;:object} 提供的R类型工具类1234567891011121314151617181920212223242526272829303132333435@Datapublic class R&lt;T&gt; { private int code; private T data; private String msg; public R() { } public static &lt;T&gt; R&lt;T&gt; ok(T data) { return fill(data,ApiCommonCodeEnum.OK); } public static &lt;T&gt; R&lt;T&gt; failed(String msg) { return fill( null, ApiCommonCodeEnum.FAIL); } public static &lt;T&gt; R&lt;T&gt; failed(ApiCommonCodeEnum apiEnum) { return fill( null, apiEnum); } public static &lt;T&gt; R&lt;T&gt; fill(T data, ApiCommonCodeEnum apiEnum) { return fill(apiEnum.getCode(),data,apiEnum.getMsg()); } public static &lt;T&gt; R&lt;T&gt; fill(int code,T data,String msg) { R R = new R(); R.setCode(code); R.setData(data); R.setMsg(msg); return R; }}//使用举例@PostMapping(&quot;/login&quot;)public R&lt;UserInfoVO&gt; login(@RequestBody LoginDTO loginDTO){ UserInfoVO userInfoVO=new UserInfoVO(); userInfoVO.setNickname(&quot;编程之家&quot;); userInfoVO.setToken(&quot;xxx&quot;); return R.ok(userInfoVO);} 状态码设计这里我们可以参考Http状态码设计，每种业务类型定义一个状态码区间，抽出放在枚举类中 123456789101112131415161718192021222324252627public enum ApiCommonCodeEnum { FAIL(1,&quot;调用出错&quot;), OK(0,&quot;调用成功&quot;), USER_EXISIT(100,&quot;用户不存在&quot;), USER_PASSWORD_ERROR(101,&quot;用户密码错误&quot;), //.... NO_PERM(300,&quot;无权限&quot;); //.... int code; String msg; ApiCommonCodeEnum(int code,String msg){ this.code=code; this.msg=msg; } public int getCode() { return code; } private void setCode(int code) { this.code = code; } public String getMsg() { return msg; } private void setMsg(String msg) { this.msg = msg; }} 千里之行，始于足下。这里是SpringBoot教程系列第二篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E6%A0%BC%E5%BC%8F%E8%BF%94%E5%9B%9E/"},{"title":"Springboot2.x基础教程：日志配置","text":"项目的开发过程中，开发人员对于日志一定不会陌生。日志能够记录程序运行的轨迹，输出软件运行中的关键信息，辅助我们排查与定位问题，优化程序运行性能，监控程序运行状态，不可不谓重要。SpringBoot项目的spring-boot-starter默认引用spring-boot-starter-logging,其中底层采用logback日志框架，默认零配置即可使用日志记录功能。在讲解springboot日志配置之前先简单谈谈JAVA日志有关的基础知识。 日志记录的时机 记录程序初始化有关启动的参数，判断程序的运行状态 代码抛出异常，记录程序异常状态 业务流程与预期结果不符，记录业务异常状态 系统核心业务，核心权限操作。比如登录、付款等操作记录，通常还会入库分析。 Java日志框架对于日志框架，我们通常会看到log4j、logback等名词，也会遇到自己项目与第三方jar的日志库冲突问题。初次接触这些，可能有种云雾缭绕不知所云的感觉，下面简单介绍下Java日志框架的关系。更具体的历史缘由，细节部分。网上有几篇文章介绍的很好，给大家附上自行阅读理解: 知乎上面有篇文章：java日志框架解析 博客上面有篇文章：Java常用日志框架介绍 看完以上文章简单的总结Java日志框架分为3类： Java日志框架的具体的实现：log4j1.x、JUL(Java Util Log)、Logback、log4j2-core Java日志框架的门面对象，只提供接口不提供具体实现：JCL(Commons Logging)、SLF4J(The Simple Logging Facade for Java)、log4j2-api Java日志框架之间的适配器，为了让不同日志框架互相转换:jcl-over-slf4j、slf4j-jcl、log4j-over-slf4j、slf4j-log4j12等等 关于日志框架的最佳实践（来源参考链接，这里只是摘出）： 总是使用Log Facade，而不是具体Log Implementation 只添加一个 Log Implementation依赖 具体的日志实现依赖应该设置为optional和使用runtime scope 如果有必要, 排除依赖的第三方库中的Log Impementation依赖 避免输出不必要的日志，跟不必要的日志字段如行号影响程序性能 SpringBoot日志配置日志依赖springboot默认使用SLF4J+Logback的组合记录日志，查看依赖可知，不用我们额外引入。 springboot日志配置1234567891011121314151617181920logging: level: #包的日志级别 org.springframework.web: DEBUG #自定义log信息 config: classpath:config/logback-spring.xml pattern: #控制台的日志输出格式 console: '%d{yyyy/MM/dd-HH:mm:ss} [%thread] %-5level %logger- %msg%n' #文件的日志输出格式 file: '%d{yyyy/MM/dd-HH:mm} [%thread] %-5level %logger- %msg%n' file: #日志名称 name: app.log #存储的路径 path: /var/log/ #存储的最大值 max-size: 50MB #保存时间 max-history: 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!--获取变量名中关于日志存储的路径与存储名称--&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;logPath&quot; source=&quot;logging.file.path&quot;/&gt; &lt;springProperty scope=&quot;context&quot; name=&quot;logName&quot; source=&quot;logging.file.name&quot;/&gt; &lt;!--输出到控制台的appender--&gt; &lt;appender name=&quot;Console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt; &lt;Pattern&gt; %black(%d{ISO8601}) %highlight(%-5level) [%blue(%t)] %yellow(%C{1.}): %msg%n%throwable &lt;/Pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!--输出到文件的appender--&gt; &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;file&gt;${logPath}/${logName}&lt;/file&gt; &lt;encoder class=&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;&gt; &lt;Pattern&gt;%d %p %C{1.} [%t] %m%n&lt;/Pattern&gt; &lt;/encoder&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt; &lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt; &lt;fileNamePattern&gt;${LOGS}/archived/spring-boot-logger-%d{yyyy-MM-dd}.%i.log &lt;/fileNamePattern&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt; &lt;maxFileSize&gt;10MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--开发环境基本级别为DEBUG--&gt; &lt;springProfile name=&quot;dev&quot;&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/springProfile&gt; &lt;!--生产环境输入到文件中--&gt; &lt;springProfile name=&quot;prod&quot;&gt; &lt;root level=&quot;INFO&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;/root&gt; &lt;/springProfile&gt;&lt;/configuration&gt; 千里之行，始于足下。这里是SpringBoot教程系列第八篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/25/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"},{"title":"Springboot2.x基础教程：自动装配原理与条件注解","text":"spring Boot采用约定优于配置的方式，大量的减少了配置文件的使用。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。当springboot启动的时候，默认在容器中注入许多AutoCongfigution类。在我们加入spring-boot-stareter-xx时，XXXAutoConfiguration类根据对应的条件，自动选择装配对应的Bean实例注入IOC容器中。 先说结论 SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration @EnableAutoConfiguration Import的AutoConfigurationImportSelector中代码最终调用SpringFactoriesLoader.loadSpringFactories扫描了Jar包的META-INF/spring.factories文件加载了大量的XXAutoConfiguration类 AutoConfiguration类配合Conditonal注解与ConfigurationProperties配置类在特定条件下自动装配我们需要的Bean到IOC容器中。 注入AutoConfiguration类核心源码分析SpringBoot的主启动类上需要加入@SpringBootApplication注解，我们看看该注解的源码。 1234567@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })public @interface SpringBootApplication { //...省略} 实际是@EnableAutoConfigurtaion注解起作用。 12345678@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration { String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default {}; String[] excludeName() default {};} 看到@Import注解是不是很熟悉，该注解作用见教程@Enable原理，主要能够导入下面3种情况中的Bean。 允许注入使用@Configuration注解的类 允许使用实现ImportSelectorj接口的类,注入selectImports返回的类 允许是实现了ImportBeanDefinitionRegistrar接口的类 AutoConfigurationImportSelector中selectImports源码 12345678@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) { if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());} 其中AutoConfigurationImportSelector.getAutoConfigurationEntry调用AutoConfigurationImportSelector.getCandidateConfigurations调用SpringFactoriesLoader.loadFactoryNames调用SpringFactoriesLoader.loadSpringFactories。 其中SpringFactoriesLoader.loadSpringFactories从指定的配置文件META-INF/spring.factories加载配置。 1234567891011121314151617181920212223242526272829303132333435private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) { MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader); if (result != null) { return result; } else { try { Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result = new LinkedMultiValueMap(); while(urls.hasMoreElements()) { URL url = (URL)urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) { Entry&lt;?, ?&gt; entry = (Entry)var6.next(); String factoryTypeName = ((String)entry.getKey()).trim(); String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue()); int var10 = var9.length; for(int var11 = 0; var11 &lt; var10; ++var11) { String factoryImplementationName = var9[var11]; result.add(factoryTypeName, factoryImplementationName.trim()); } } } cache.put(classLoader, result); return result; } catch (IOException var13) { throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13); } }} 总结： @SpringBootApplication中@EnableAutoConfiguration注解最终调用SpringFactoriesLoader.loadSpringFactories，从classpath中搜寻所有的META-INF/spring.factories配置文件 并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。 条件注解在spring-boot-autoconfigure包在META-INF/spring.factories文件中autoconfiguration配置项一览。 我们拿DataSourceAutoConfiguration源码分析，看看autoconfiguration类生效的条件。 12345678910111213141516171819202122232425262728@Configuration(proxyBeanMethods = false)@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)@EnableConfigurationProperties(DataSourceProperties.class)@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class })public class DataSourceAutoConfiguration { @Configuration(proxyBeanMethods = false) @Conditional(EmbeddedDatabaseCondition.class) @ConditionalOnMissingBean({ DataSource.class, XADataSource.class }) @Import(EmbeddedDataSourceConfiguration.class) protected static class EmbeddedDatabaseConfiguration { } @Configuration(proxyBeanMethods = false) @Conditional(PooledDataSourceCondition.class) @ConditionalOnMissingBean({ DataSource.class, XADataSource.class }) @Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class, DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class }) protected static class PooledDataSourceConfiguration { } //省略....} 在DataSourceAutoConfiguration类中，存在大量的@ConditionalXX条件注解，常见条件注解作用： @ConditionalOnBean：当SpringIoc容器内存在指定Bean的条件 @ConditionalOnClass：当SpringIoc容器内存在指定Class的条件 @ConditionalOnExpression：基于SpEL表达式作为判断条件 @ConditionalOnJava：基于JVM版本作为判断条件 @ConditionalOnJndi：在JNDI存在时查找指定的位置 @ConditionalOnMissingBean：当SpringIoc容器内不存在指定Bean的条件 @ConditionalOnMissingClass：当SpringIoc容器内不存在指定Class的条件 @ConditionalOnNotWebApplication：当前项目不是Web项目的条件 @ConditionalOnProperty：指定的属性是否有指定的值 @ConditionalOnResource：类路径是否有指定的值 @ConditionalOnSingleCandidate：当指定Bean在SpringIoc容器内只有一个，或者虽然有多个但是指定首选的Bean @ConditionalOnWebApplication：当前项目是Web项目的条件 @EnableConfigurationProperties注解：使使用 @ConfigurationProperties 注解的类生效。我们可以看在DataSourceAutoConfiguration激活了DataSourceProperties配置，并且根据条件注解在不同情况下加载不同的数据源到IOC容器中。 千里之行，始于足下。这里是SpringBoot教程系列第十七篇，所有项目源码均可以在我的GitHub上面下载源码。觉得不错可以评论、点赞、转发3连。","link":"/2023/09/25/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E4%B8%8E%E6%9D%A1%E4%BB%B6%E6%B3%A8%E8%A7%A3/"},{"title":"Springboot2.x基础教程：过滤器和拦截器详解","text":"在springboot web项目开发过程中，我们通常需要对请求与响应的内容请求拦截处理，如进行请求日志记录、UA检查、用户权限验证、非法内容过滤等功能，这时候过滤器与拦截器就派上用场。本文带大家讲解springboot如何使用过滤器与拦截器以及两者之间的区别。 过滤器Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法： 1234567public interface Filter { default void init(FilterConfig filterConfig) throws ServletException { } void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException; default void destroy() { }} 序号 方法&amp;描叙 1 doFilter该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。 2 initweb 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 3 destroyServlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。 SpringBoot使用过滤器定义了一个简单的过滤器 12345678910111213141516171819@Slf4jpublic class LogFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req=(HttpServletRequest)servletRequest; log.info(req.getRequestURI()); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { }} 使用FilterRegistrationBean注册过滤器 123456789101112131415@Configurationpublic class LogFilterConfiguration { @Bean public FilterRegistrationBean registrationBean(){ FilterRegistrationBean registrationBean=new FilterRegistrationBean(); registrationBean.setFilter(new LogFilter()); //匹配的过滤器 registrationBean.addUrlPatterns(&quot;/*&quot;); //过滤器名称 registrationBean.setName(&quot;logFilter&quot;); //过滤器顺序 registrationBean.setOrder(1); return registrationBean; }} 使用Servlet3.0注解定义过滤器 12345678910@WebFilter(urlPatterns = &quot;/*&quot;,filterName = &quot;authFiler&quot;)@Slf4jpublic class AuthFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain) throws IOException, ServletException { log.info(&quot;进行权限校验.........&quot;); chain.doFilter(servletRequest,servletResponse); }} 两种方式的区别： WebFilter这个注解并没有指定执行顺序的属性，其执行顺序依赖于Filter的名称，是根据Filter类名（注意不是配置的filter的名字）的字母顺序倒序排列 @WebFilter指定的过滤器优先级都高于FilterRegistrationBean配置的过滤器 FilterRegistrationBean方式可以注入SpringBoot IOC容器中的Bean 拦截器SpringBoot拦截器Interceptor类似 面向切面编程 中的 切面 和 通知，我们通过 动态代理 对一个 service() 方法添加 通知 进行功能增强。比如说在方法执行前进行 初始化处理，在方法执行后进行 后置处理。拦截器 的思想和 AOP 类似，区别就是 拦截器 只能对 Controller 的 HTTP 请求进行拦截。 1234567891011public interface HandlerInterceptor { default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { }} 序号 方法&amp;描叙 1 preHandle该方法在controller接收请求处理request之前执行，返回值为 boolean，返回值为 true 时接着执行 postHandle() 和 afterCompletion() 方法；如果返回false则中断执行。 2 postHandle 在 controller 处理请求之后， ModelAndView 处理前执行，可以对 响应结果 进行修改。 3 afterCompletion在 DispatchServlet 对本次请求处理完成，即生成 ModelAndView 之后执行。 定义一个简单的拦截器 123456789101112131415161718192021222324252627@Slf4jpublic class LogHandler implements HandlerInterceptor { private NamedThreadLocal&lt;Long&gt; startTimeThreadLocal = new NamedThreadLocal&lt;&gt;(&quot;StopWatch-StartTime&quot;); public LogHandler() { super(); } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { long beginTime = System.currentTimeMillis();//1、开始时间 startTimeThreadLocal.set(beginTime);//线程绑定变量（该数据只有当前请求的线程可见） return true;//继续流程 } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { long endTime = System.currentTimeMillis(); long beginTime = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间） long consumeTime = endTime - beginTime; //3、消耗的时间 log.info(String.format(&quot;%s consume %d millis&quot;, request.getRequestURI(), consumeTime)); } } 注册拦截器 1234567@Configurationpublic class HandlerConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new LogHandler()); }} 过滤器与拦截器区别 序号 区别 1 Filter是servlet规范，使用范围是web程序，拦截器不限于web程序，也可以用于Application、Swing程序中 2 Filter是servlet规范中定义，是servlet容器支持的。拦截器是Spring容器内，是spring框架支持的 3 拦截器是Spring的一个组件，能够使用spring中对象，如Service对象、数据源、事务管理、通过IOC注入容器即可，filter则不能 4 filter在servlet前后起作用，拦截器能够深入方法的前后，异常抛出前后。 5 在springboot项目中一般优先使用拦截器 千里之行，始于足下。这里是SpringBoot教程系列第十二篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AF%A6%E8%A7%A3/"},{"title":"Springboot2.x基础教程：配置文件详解","text":"当使用Spring Initializr构建springboot项目时，会自动在src/main/resources下生产application.properties文件。今天我们就来聊聊SpringBoot的配置文件。 配置文件的作用SpringBoot采用“习惯优于配置”的理念，项目中存在大量的配置，采用默认配置，让你无需手动配置。SpringBoot能够识别properties格式与yml格式的配置文件（我们一般使用yml格式更多）。当需要对默认配置进行修改或者自定义配置时可用通过修改配置文件达到目的。 配置文件的基本使用这是使用yml格式的配置举例，说明application.yml中如何配置，以及代码中如何获取。 数字，字符串，布尔获取配置文件写法： 123version: 1.0author: codhome.vipflag: true 使用@Value获取: 1234567@Value(&quot;${version}&quot;)float version;@Value(&quot;${author}&quot;)String author;//这里的true为默认值@Value(&quot;${flag:true}&quot;)boolean flag; 对象、Map写法与获取配置文件写法： 1234user: userName: codehome age: 18 forbidden: true 使用@ConfigurationProperties获取: 1234567891011@Configuration@ConfigurationProperties(prefix = &quot;user&quot;)@Datapublic class UserProperties { String userName; int age; boolean forbidden;}//注入使用@AutowiredUserProperties userProperties; List、Set、Array获取配置文件写法： 1random: 10,20,30 使用@Value获取: 12@Value(&quot;#{'${random}'.split(',')}&quot;)int[] randoms; //List&lt;Integer&gt;也可以 配置文件写法： 12345random1: users: - zhangsao - lisi - wangwu 使用@ConfigurationProperties获取: 123456@Configuration@ConfigurationProperties(prefix = &quot;random1&quot;)@Datapublic class UserProperties { List&lt;String&gt; users;} 总结下两种注解区别 多环境配置我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml,使用spring.profiles.active激活使用哪一个配置文件 1234567891011121314151617181920212223242526spring: profiles: active: dev---#配置开发环境spring: profiles: devserver: port: 9000---#配置生产环境spring: profiles: prodserver: port: 9100---#配置测试环境spring: profiles: devserver: port: 8000 配置文件优先级项目内部配置文件 application.properties 与application.yml同一个目录共存时，properties配置优先级更高 ConfigFileApplicationListener中默认配置文件加载顺序项目根目录config文件夹&gt;根目录配置文件&gt;resources下config文件夹&gt;resources下配置文件 当多个配置文件属性不冲突时，配置是互补的 也可以指定配置文件地址1java -jar run-0.0.1-SNAPSHOT.jar --spring.config.location=D:/application.properties 外部配置官方参考链接 Devtools global settings properties in the $HOME/.config/spring-boot directory when devtools is active. @TestPropertySource annotations on your tests. properties attribute on your tests. Available on @SpringBootTest and the test annotations for testing a particular slice of your application. Command line arguments. Properties from SPRING_APPLICATION_JSON (inline JSON embedded in an environment variable or system property). ServletConfig init parameters. ServletContext init parameters. JNDI attributes from java:comp/env. Java System properties (System.getProperties()). OS environment variables. A RandomValuePropertySource that has properties only in random.*. Profile-specific application properties outside of your packaged jar (application-{profile}.properties and YAML variants). Profile-specific application properties packaged inside your jar (application-{profile}.properties and YAML variants). Application properties outside of your packaged jar (application.properties and YAML variants). Application properties packaged inside your jar (application.properties and YAML variants). @PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins. Default properties (specified by setting SpringApplication.setDefaultProperties). 千里之行，始于足下。这里是SpringBoot教程系列第五篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/23/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"title":"Springboot2.x基础教程：集成mybatis最佳实践","text":"前面文章介绍过SpringBoot结合Jpa实现对数据库的操作。今天介绍下SprigBoot集成Mybatis的相关知识点。Mybatis作为一个半自动化的ORM框架,根据条件动态拼接SQL，是其一大优点。贴合原生SQL的写法，方便开发人员灵活的编写复杂的SQL语句。SpringBoot集成Mybatis的配置还是相当简单的，教程并且会给出常见针对Mysql数据CURD、分页、批量操作的写法。 SpringBoot配置Mybatis引入依赖1234567891011121314151617&lt;!--mybatis依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt;&lt;/dependency&gt;&lt;!--分页依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 配置数据源这里使用springboot默认的数据连接池hikari,号称最快的数据库链接池，allowMultiQueries=true开启批量更新。 1234567891011121314spring: datasource: url: jdbc:mysql://localhost:3306/spring?autoReconnect=true&amp;useSSL=false&amp;characterEncoding=utf-8&amp;failOverReadOnly=false&amp;allowMultiQueries=true driver-class-name: com.mysql.jdbc.Driver username: root password: 123456 hikari: maximum-pool-size: 50 connection-test-query: SELECT 1 #1分钟后释放 idle-timeout: 600000 minimum-idle: 10 auto-commit: true validation-timeout: 250 配置Mybatis参数这里有两种配置一种直接在springboot默认的application.yml中配置，一种单独提取出来配置，本文采用第二种。 12345mybatis: #指定配置mybatis参数配置地址 config-location: classpath:mybatis-config.xml #指定接口xml地址 mapper-locations: classpath:mappers/*.xml 这里贴出mybatis-config.xml的配置: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!-- 全局参数 --&gt; &lt;settings&gt; &lt;!-- 使全局的映射器启用或禁用缓存。 --&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 全局启用或禁用延迟加载。当禁用时，所有关联对象都会即时加载。 --&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 当启用时，有延迟加载属性的对象在被调用时将会完全加载任意属性。否则，每种属性将会按需要加载。 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否允许单条sql 返回多个数据集 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 是否可以使用列的别名 (取决于驱动的兼容性) default:true --&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;!-- 允许JDBC 生成主键。需要驱动器支持。如果设为了true，这个设置将强制使用被生成的主键，有一些驱动器不兼容不过仍然可以执行。 default:false --&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;true&quot;/&gt; &lt;!-- 指定 MyBatis 如何自动映射 数据基表的列 NONE：不隐射 PARTIAL:部分 FULL:全部 --&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;!-- 这是默认的执行类型 （SIMPLE: 简单； REUSE: 执行器可能重复使用prepared statements语句；BATCH: 执行器可以重复执行语句和批量更新） --&gt; &lt;!-- 对于批量更新操作缓存SQL以提高性能 BATCH,SIMPLE --&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;!-- 数据库超过25000秒仍未响应则超时 --&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25000&quot;/&gt; &lt;!-- 使用驼峰命名法转换字段。 --&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置本地缓存范围 session:就会有数据的共享 statement:语句范围 (这样就不会有数据的共享 ) defalut:session --&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;!-- 设置但JDBC类型为空时,某些驱动程序 要指定值,default:OTHER，插入空值时不需要指定类型 --&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;NULL&quot;/&gt; &lt;!-- 设置关联对象加载的形态，此处为按需加载字段(加载字段由SQL指 定)，不会加载关联表的所有字段，以提高性能 --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;org.apache.ibatis.logging.stdout.StdOutImpl&quot;/&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;!--批量别名，默认为别名的规范就是对应包装类的类名首字母变为小写--&gt; &lt;package name=&quot;vip.codehome.springboot.tutorials.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;plugins&gt; &lt;!--pagehelper分页插件--&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;!-- 使用MySQL方言的分页 --&gt; &lt;property name=&quot;helperDialect&quot; value=&quot;sqlserver&quot;/&gt;&lt;!--如果使用mysql，这里value为mysql--&gt; &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/configuration&gt; 增删改查最优写法针对这张表给出Mybatis常见动态SQL写法首先编辑Mapper层接口，注意要加上@Mapper注解 123456789101112131415161718@Mapper@Repositorypublic interface UserMapper { //插入 int insert(UserDO userDO); //分页查询 List&lt;UserDO&gt; select(UserDO userDO); //更新 int update(UserDO userDO); //删除 int delete(UserDO userDO); //批量插入 int insertBatch(List&lt;UserDO&gt; list); //批量更新 int updateBatch(List&lt;UserDO&gt; list); //批量删除 int deleteBatch(Long[] array);} 前面配置了mapper-locations为classpath:mappers/*.xml，即mapper对应的xml文件放在src/main/resources/mappers目录下, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;vip.codehome.springboot.tutorials.mapper.UserMapper&quot;&gt; &lt;sql id=&quot;base&quot;&gt; id,name,account,age,forbidden,login_time,passwd &lt;/sql&gt; &lt;insert id=&quot;insert&quot; parameterType=&quot;userDO&quot;&gt; insert into tb_user( &lt;trim suffixOverrides=&quot;,&quot;&gt; id, account, passwd, name, &lt;if test=&quot;age!=null&quot;&gt; age, &lt;/if&gt; &lt;if test=&quot;forbidden!=null and forbidden!=''&quot;&gt; forbidden, &lt;/if&gt; &lt;if test=&quot;loginTime!=null&quot;&gt; login_time, &lt;/if&gt; &lt;/trim&gt; )values ( &lt;trim suffixOverrides=&quot;,&quot;&gt; #{id}, #{account}, #{passwd}, #{name}, &lt;if test=&quot;age!=null&quot;&gt; #{age}, &lt;/if&gt; &lt;if test=&quot;forbidden!=null and forbidden!=''&quot;&gt; #{forbidden}, &lt;/if&gt; &lt;if test=&quot;loginTime!=null&quot;&gt; #{loginTime}, &lt;/if&gt; &lt;/trim&gt; ) &lt;/insert&gt; &lt;select id=&quot;select&quot; resultType=&quot;userDO&quot;&gt; select &lt;include refid=&quot;base&quot;/&gt; from tb_user &lt;where&gt; &lt;if test=&quot;account!=null and account!=''&quot;&gt; and account=#{account} &lt;/if&gt; &lt;if test=&quot;name!=null and name!=''&quot;&gt; and name like concat('%',#{name},'%') &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;userDO&quot;&gt; update tb_user &lt;set&gt; &lt;if test=&quot;name!=null and name!=''&quot;&gt; name=#{name}, &lt;/if&gt; &lt;if test=&quot;age!=null&quot;&gt; age=#{age} &lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/update&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;userDO&quot;&gt; delete from tb_user where id=#{id} &lt;/delete&gt; &lt;insert id=&quot;insertBatch&quot; parameterType=&quot;list&quot; useGeneratedKeys=&quot;true&quot;&gt; &lt;selectKey resultType=&quot;long&quot; keyProperty=&quot;id&quot; order=&quot;AFTER&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into tb_user( account,passwd,name,age,forbidden,login_time )values &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; (#{user.account}, #{user.passwd}, #{user.name}, #{user.age}, #{user.forbidden}, #{user.loginTime}) &lt;/foreach&gt; &lt;/insert&gt; &lt;update id=&quot;updateBatch&quot; parameterType=&quot;list&quot;&gt; &lt;foreach collection=&quot;list&quot; item=&quot;user&quot; index=&quot;index&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;;&quot;&gt; update tb_user &lt;set&gt; &lt;if test=&quot;name!=null and name!=''&quot;&gt; name=#{name}, &lt;/if&gt; &lt;if test=&quot;age!=null&quot;&gt; age=#{age} &lt;/if&gt; &lt;/set&gt; where id=#{id} &lt;/foreach&gt; &lt;/update&gt; &lt;delete id=&quot;deleteBatch&quot; parameterType=&quot;long&quot;&gt; delete from tb_user where id in &lt;foreach collection=&quot;array&quot; item=&quot;id&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt; #{id} &lt;/foreach&gt; &lt;/delete&gt;&lt;/mapper&gt; 单元测试用例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@RunWith(SpringRunner.class)@SpringBootTestpublic class UserMapperTest { @Autowired UserMapper userMapper; //插入 @Test public void testAdd(){ UserDO userDO=new UserDO(); userDO.setPasswd(&quot;codehome&quot;); userDO.setAccount(&quot;codehome&quot;); userDO.setName(&quot;name&quot;); userDO.setForbidden(true); userDO.setLoginTime(LocalDateTime.now()); userMapper.insert(userDO); } //分页 @Test public void page(){ PageHelper.startPage(0,10); UserDO userDO=new UserDO(); userDO.setName(&quot;n&quot;); PageInfo&lt;UserDO&gt; userDOPage= new PageInfo&lt;&gt;(userMapper.select(userDO)); } //更新 @Test public void update(){ UserDO userDO=new UserDO(); userDO.setId(1L); userDO.setName(&quot;编程之家&quot;); userMapper.update(userDO); } //删除 @Test public void delete(){ UserDO userDO=new UserDO(); userDO.setId(1L); userMapper.delete(userDO); } //批量插入 @Test public void testAddBatch(){ UserDO userDO=new UserDO(); userDO.setPasswd(&quot;codehome&quot;); userDO.setAccount(&quot;codehome&quot;); userDO.setName(&quot;name&quot;); userDO.setForbidden(true); userDO.setLoginTime(LocalDateTime.now()); UserDO userDO1=new UserDO(); userDO1.setPasswd(&quot;codehome&quot;); userDO1.setAccount(&quot;codehome&quot;); userDO1.setName(&quot;name&quot;); userDO1.setForbidden(true); userDO1.setLoginTime(LocalDateTime.now()); userMapper.insertBatch(Arrays.asList(userDO,userDO1)); } //批量更新 @Test public void testUpdateBatch(){ UserDO userDO=new UserDO(); userDO.setPasswd(&quot;codehome1&quot;); userDO.setAccount(&quot;codehome1&quot;); userDO.setName(&quot;name1&quot;); userDO.setId(1L); userDO.setForbidden(true); userDO.setLoginTime(LocalDateTime.now()); UserDO userDO1=new UserDO(); userDO.setId(2L); userDO1.setPasswd(&quot;codehome2&quot;); userDO1.setAccount(&quot;codehome2&quot;); userDO1.setName(&quot;name2&quot;); userDO1.setForbidden(true); userDO1.setLoginTime(LocalDateTime.now()); userMapper.insertBatch(Arrays.asList(userDO,userDO1)); } @Test public void deleteBatch(){ userMapper.deleteBatch(new Long[]{1L,2L}); }} 这里举出的例子使用了if、set、where、foreach、trim、sql等标签，更详细的解释可以参考官方动态 SQL以上就是对springboot集成Mybatis的配置，跟常见CURD与批量操作，更多的内容篇幅有限大家可以参考文中给出的链接。千里之行，始于足下。这里是SpringBoot教程系列第十四篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/25/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E9%9B%86%E6%88%90mybatis%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"title":"Springboot2.x基础教程：集成spring-data-jpa","text":"Spring Data是Spring 社区的一个子项目，主要用于简化数据（关系型&amp;非关系型）访问，其主要目标是使得数据库的访问变得方便快捷。目前支持的关系型与非关系型数据有Spring data JPA、Mongodb、Redis、JDBC、Elasticsearch….具体可查看Spring官网JPA全称为Java Persistence API（Java持久层API），它是Sun公司在JavaEE 5中提出的Java持久化规范。它为Java开发人员提供了一种对象/关联映射工具，来管理Java应用中的关系数据，JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。很多ORM框架都是实现了JPA的规范，如：Hibernate、EclipseLink。Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，底层使用了 Hibernate 的 JPA 技术实现，可使开发者用极简的代码即可实现对数据的访问和操作。它提供了包括增删改查等在内的常用功能，且易于扩展！学习并使用 Spring Data JPA 可以极大提高开发效率。 SpringBoot集成Spring-data-jpa引入JPA依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--以操作Mysql数据库为例，引入Mysql数据库驱动--&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; jpa与Mysql配置spring.hibernate.ddl-auto配置介绍： create:每次删除上次的表，根据model重新生成新表，一般用于测试，会丢失数据。[删除-创建-操作] create-drop：每次加载 hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。[删除-创建-操作-再删除] update: 最常用的属性，第一次加载 hibernate 时根据 model 类会自动建立起表的结构（前提是先建立好数据库），以后加载 hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。[没表-创建-操作 | 有表-更新没有的属性列-操作] validate: 每次加载 hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。[启动验证表结构，验证不成功，项目启动失败] 12345678910111213spring: datasource: url: jdbc:mysql://localhost:3306/mytestdb?serverTimezone=UTC&amp;useSSL=false&amp;allowPublicKeyRetrieval=true username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver jpa: hibernate: ddl-auto: create #设置数据库方言 database-platform: org.hibernate.dialect.MySQL5InnoDBDialect #打印sql show-sql: true 关于数据库表映射的注解 @Entity: 指定映射的表名 @Id：指定主键 @GeneratedValue：主键生成策略 @Column: 指定映射的列名 @Temporal: 关于时间的精度 @Transient: 实体类忽略映射的字段12345678910111213141516171819@Entity(name = &quot;tb_user&quot;)@Data@NoArgsConstructor@AllArgsConstructorpublic class UserDO implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Column(name = &quot;name&quot;,nullable = false) String userName; String account; String passwd; int age; boolean forbidden; @Temporal(value = TemporalType.TIMESTAMP) Date loginTime; @Transient String token;} 增删改查是不是很简单??? 只要继承JpaRepository就能通过UserRepository实现对一个实体的CURD操作。 123@Repositorypublic interface UserRepository extends JpaRepository&lt;UserDO,Long&gt; {} 分页、排序、自定义语句查询1234567891011@Repositorypublic interface UserRepository extends JpaRepository&lt;UserDO,Long&gt; { @Query(&quot;from tb_user u where u.userName like :userName&quot;) Page&lt;UserDO&gt; findUserDOByUserName(@Param(&quot;userName&quot;)String userName, Pageable pageable); Page&lt;UserDO&gt; findAll(Pageable pageable);}//使用方法Pageable pageable= PageRequest.of(0,10);Page&lt;UserDO&gt; pageUsers=userRepository.findAll(pageable,Sort.by(&quot;age&quot;).ascending().and(Sort.by(&quot;userName&quot;).descending()));List&lt;UserDO&gt; users=pageUsers.getContent();int totalPages= pageUsers.getTotalPages(); 方法命名规则查询1234@Repositorypublic interface UserRepository extends JpaRepository&lt;UserDO,Long&gt; { List&lt;UserDO&gt; findUserDOByAccountAndAgeAndUserNameLike(String account,int age,String userName);} 更多使用方法：Jpa官方文档地址：https://docs.spring.io/spring-data/jpa/docs/2.3.2.RELEASE/reference/html/#reference千里之行，始于足下。这里是SpringBoot教程系列第六篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/25/springboot/Springboot2.x%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%EF%BC%9A%E9%9B%86%E6%88%90spring-data-jpa/"},{"title":"Spring事务详解","text":"事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务特性(ACID) Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。[1] Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。[1] Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。[1] Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 Spring事务管理接口​ Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。 Spring事务管理器的接口是： org.springframework.transaction.PlatformTransactionManager ，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。 PlatformTransactionManager核心方法12345678910public interface PlatformTransactionManager extends TransactionManager { //根据指定的传播行为，返回当前活动的事务或创建一个新事务 TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException; //使用事务目前的状态提交事务 void commit(TransactionStatus status) throws TransactionException; //对执行的事务进行回滚 void rollback(TransactionStatus status) throws TransactionException;} TransactionDefinition事务定义 事务的传播行为 事务隔离级别 事务名称 事务超时时间 是否为只读事务 12345678910111213public interface TransactionDefinition { // 返回事务的传播行为 int getPropagationBehavior(); // 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据 int getIsolationLevel(); // 返回事务必须在多少秒内完成 //返回事务的名字 String getName()； int getTimeout(); // 返回是否优化为只读事务。 boolean isReadOnly();} 事务的传播行为简单的来说，多个事务方法相互调用时,事务如何在这些方法间传播。 举个栗子，方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务以及方法B对事务的要求不同都会对方法A的事务具体执行造成影响，同时方法A的事务对方法B的事务执行也有影响，这种影响具体是什么就由两个方法所定义的事务传播类型所决定。 支持外层事务情况 Required: 当前外层存在事务，加入当前事务。没有自己创建新一个事务。 Supports: 当前外层存在事务，加入当前事务。没有自己以非事务方式运行。 Mandatory: 当前外层存在事务，加入当前事务。没有当前事务，抛出异常。 不支持外层事务情况 Required_NEW: 创建一个新事务，当前外层存在事务，则挂起当前事务。 Not_Supported: 以非事务方式运行。当前外层存在事务，则挂起当前事务。 Never: 以非事务方式运行。当前外层存在事务，则抛出异常。 其他情况 Nested: 当前外层存在事务，则创建一个嵌套事务作为当前事务的嵌套事务来运行。没有等于Required。 事务的隔离级别定义了一个事务可能受其他并发事务影响的程度。 TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别. TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读 TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生 TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 Spring事务集成声明式事务通过在方法或类或接口上添加注解进行包装，无侵入地实现事务，更方便，但粒度更大。 123456@Transactional(propagation = Propagation.REQUIRED,timeout = 3000,rollbackFor = Exception.class)public Integer save(Integer id,String name){ String insertSql=&quot;insert into `tb_user`(`id`,`name`)values(?,?);&quot;; jdbcTemplate.update(insertSql,id,name); return jdbcTemplate.queryForObject(&quot;select count(*) from tb_user&quot;,Integer.class);} 编程式事务通过编码的方式手动启用、提交或回滚事务，粒度更细，但更麻烦。 1234567891011121314151617181920212223242526 public Integer save(Integer id,String name){ Integer num=transactionTemplate.&lt;Integer&gt;execute((TransactionStatus status)-&gt;{ try{ String insertSql=&quot;insert into `tb_user`(`id`,`name`)values(?,?);&quot;; jdbcTemplate.update(insertSql,id,name); }catch (Exception e){ e.printStackTrace(); status.setRollbackOnly(); } return jdbcTemplate.queryForObject(&quot;select count(*) from tb_user&quot;,Integer.class); }); return num; }//或者 public Integer save2(Integer id,String name){ TransactionStatus transactionStatus=transactionManager.getTransaction(new DefaultTransactionDefinition()); try{ String insertSql=&quot;insert into `tb_user`(`id`,`name`)values(?,?);&quot;; jdbcTemplate.update(insertSql,id,name); transactionManager.commit(transactionStatus); }catch (Exception e){ e.printStackTrace(); transactionManager.rollback(transactionStatus); } return jdbcTemplate.queryForObject(&quot;select count(*) from tb_user&quot;,Integer.class); } AOP全局事务一般在项目中使用等待全局性事务，拦截特定包下面的特定方法，不推荐使用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Aspect@Component //事务依然生效@ConditionalOnBean(DataSource.class)public class TxAdviceInterceptor { private Logger logger = LoggerFactory.getLogger(this.getClass()); @Value(&quot;${tx.timeout:5}&quot;) private int TX_METHOD_TIMEOUT = 5; private String AOP_POINTCUT_EXPRESSION = &quot;execution(* codehome.vip.*.service.*.*(..)) &quot;; @Autowired private PlatformTransactionManager transactionManager; @Bean public TransactionInterceptor txAdvice() { NameMatchTransactionAttributeSource source = new NameMatchTransactionAttributeSource(); /*只读事务，不做更新操作*/ RuleBasedTransactionAttribute readOnlyTx = new RuleBasedTransactionAttribute(); readOnlyTx.setReadOnly(true); readOnlyTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED); /*当前存在事务就使用当前事务，当前不存在事务就创建一个新的事务*/ RuleBasedTransactionAttribute requiredTx = new RuleBasedTransactionAttribute(); requiredTx.setRollbackRules( Collections.singletonList(new RollbackRuleAttribute(Exception.class))); requiredTx.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); requiredTx.setTimeout(TX_METHOD_TIMEOUT); Map&lt;String, TransactionAttribute&gt; txMap = new HashMap&lt;&gt;(); txMap.put(&quot;save*&quot;, requiredTx); txMap.put(&quot;update*&quot;, requiredTx); txMap.put(&quot;remove*&quot;, requiredTx); txMap.put(&quot;*&quot;, readOnlyTx); source.setNameMap(txMap); TransactionInterceptor txAdvice = new TransactionInterceptor(transactionManager, source); if (logger.isInfoEnabled()) { logger.info(&quot;事务管理器启动成功！&quot;); } return txAdvice; } @Bean public Advisor txAdviceAdvisor() { AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(AOP_POINTCUT_EXPRESSION); return new DefaultPointcutAdvisor(pointcut, txAdvice()); }}","link":"/2023/09/25/springboot/Spring%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3/"},{"title":"springboot项目打包瘦身","text":"默认情况下，Spring Boot 项目发布时会将项目代码和项目的所有依赖文件一起打成一个可执行的 jar 包。但如果项目的依赖包很多，那么这个文件就会非常大。这样每次即使只改动一点东西，就需要将整个项目重新打包部署，我们将依赖 lib 从项目分离出来，这样每次部署只需要发布项目源码即可。 瘦身打包配置springboot默认使用spring-boot-maven-plugin 来打包，这个插件会将项目所有的依赖打入项目jar 包里面，将打包插件替换为 maven-jar-plugin，并拷贝依赖到 jar 到外面的 lib 目录。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;build&gt; &lt;plugins&gt; &lt;!-- 指定启动类，将依赖打成外部jar包 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;!-- 生成的jar中，不要包含pom.xml和pom.properties这两个文件 --&gt; &lt;addMavenDescriptor&gt;false&lt;/addMavenDescriptor&gt; &lt;manifest&gt; &lt;!-- 是否要把第三方jar加入到类构建路径 --&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;!-- 外部依赖jar包的最终位置 --&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;!-- 项目启动类 --&gt; &lt;mainClass&gt;vip.codehome.springboot.tutorials.SpringbootTutorialsApplication&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--拷贝依赖到jar外面的lib目录--&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-lib&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;target/lib&lt;/outputDirectory&gt; &lt;excludeTransitive&gt;false&lt;/excludeTransitive&gt; &lt;stripVersion&gt;false&lt;/stripVersion&gt; &lt;includeScope&gt;runtime&lt;/includeScope&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; ​ 项目打包时会在target目录生成lib依赖包跟项目jar包，部署时将项目 jar 包以及 lib 文件夹上传到服务器上，使用java -jar 命令启动即可。如果后续仅仅修改了项目代码，只需上传替换项目 jar 包。 千里之行，始于足下。这里是SpringBoot教程系列第十八篇，所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/25/springboot/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E7%98%A6%E8%BA%AB/"},{"title":"谈一谈SpringBoot怎么使用事件机制","text":"观察者模式 对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub/Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。 观察者模式主要由以下四个角色组成，分别是抽象主题角色、抽象观察者角色、具体主题角色、具体观察者角色。 抽象主题角色​ 把所有观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者角色，一般用一个抽象类或接口来实现。JDk内置实现的抽象主题角色Observable类。 具体主题角色在具体主题内部状态改变时，给所有登记过的观察者发出通知，具体主题角色通常用一个子类实现。写一个类(具体主题角色)继承Observable（抽象主题角色），只需要写一个change方法即可 (该方法作用是通知已注册的具体主题角色更新自己) 12345678910111213/** * 具体主题角色(被观察者)，在自身一些状态变更时通知观察者 * 这里应用被人注册了，观察观察者 * @author codehome * */public class AppObservable extends Observable{ public void registry(String userName) { setChanged(); notifyObservers(userName); }} 抽象观察者角色为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。JDK内置的Observer接口。 具体观察者角色该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调，如果需要，具体观察者角色可以有一个指向具体主题角色的引用，通常用一个子类实现 123456789101112131415/** * 具体观察者，实现更新方法 * @author codehome * */public class AppWatcher implements Observer{ @Override public void update(Observable o, Object arg) { if(o instanceof AppObservable) { System.out.println(o); System.out.println(arg); } }} 使用举例123456789101112public class SubPubDemo { public static void main(String[] args) { //主题角色，被观察者 AppObservable appObservable=new AppObservable(); //观察者 AppWatcher appWatcher=new AppWatcher(); //添加观察者 appObservable.addObserver(appWatcher); //调用更新方法 appObservable.registry(&quot;zhangsan&quot;); }} 事件机制 JDK 1.0及更早版本的事件模型基于职责链模式，但是这种模型不适用于复杂的系统，因此在JDK 1.1及以后的各个版本中，事件处理模型采用基于观察者模式的委派事件模型(DelegationEvent Model, DEM)，即一个Java组件所引发的事件并不由引发事件的对象自己来负责处理，而是委派给独立的事件处理对象负责。 事件机制一般需要3个角色，事件触发源(event source)、事件状态对象(event object)、事件监听者(event listener)。 事件状态对象JDK内置的事件状态对象EventObject,持有事件触发源。 12345678910111213141516171819public class EventObject implements java.io.Serializable { private static final long serialVersionUID = 5516075349620653480L; //事件触发源 protected transient Object source; public EventObject(Object source) { if (source == null) throw new IllegalArgumentException(&quot;null source&quot;); this.source = source; } public Object getSource() { return source; } public String toString() { return getClass().getName() + &quot;[source=&quot; + source + &quot;]&quot;; }} 事件监听者JDK内置的事件监听接口 12public interface EventListener {} Spring内置的事件发布订阅上面介绍了观察者与发布者模式，与事件机制。举例总结来说如下图： graph LR 车/事件触发源 --更新状态--&gt; 坏了/事件状态 --事件管理器通知--&gt; 车主/事件监听者 ApplicationEventApplicationEvent实现了JDK的EventObject接口，为事件状态，持有事件触发源。 ApplicationListenerApplicationListener实现了JDK的Eventlistener接口，为事件监听者接口。 ApplicationEventMulticasterApplicationEventMulticaster为事件监听者与事件状态的管理接口，管理事件状态与监听器的关系。 SpringBoot如何使用事件发布订阅机制1234567891011121314151617//继承ApplicationEvent接口，定义一个事件状态public class AppStatusEvent extends ApplicationEvent { /** * Create a new ApplicationEvent. * * @param source the object on which the event initially occurred (never {@code null}) */ AppDO appDO; public AppStatusEvent(Object source,AppDO appDO) { super(source); this.appDO=appDO; } public AppDO getAppDO() { return appDO; }} 123456789101112131415//监听对应事件的事件监听器@Component@Slf4jpublic class AppStatusListener { @EventListener @Async public void onApplicationEvent(AppStatusEvent event){ AppDO appDO=event.getAppDO(); if(AuthUtil.commomCheck(appDO)){ log.info(&quot;{}被禁用,开始关闭与imf系统的收发&quot;,appDO.getAppName()); SessionUtil.forbidden(appDO.getAppCode()); } }} 1234//发布事件@AutowiredApplicationEventPublisher eventPublisher;eventPublisher.publishEvent(new AppStatusEvent(this,app)); 千里之行，始于足下。这里是SpringBoot教程系列关于spring的事件机制，本教程所有项目源码均可以在我的GitHub上面下载源码。","link":"/2023/09/25/springboot/%E8%B0%88%E4%B8%80%E8%B0%88SpringBoot%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"},{"title":"贡献一个springboot项目linux shell启动脚本","text":"springboot打好的包放在/usr/local/app目录下，如App.jar改名为mv App.jar Appspringboot配置外提为App.yml也放在当前目录下,日志生成为App.log 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#!/bin/bash #这里可替换为你自己的执行程序,其他代码无需更改 APP_NAME=$1JAR_NAME=/usr/local/app/${APP_NAME} JVM=&quot;-server -Xms2048m -Xmx2048m -XX:PermSize=1024M -XX:MaxNewSize=512m -XX:MaxPermSize=2048m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled&quot;APPFILE_PATH=&quot;-Dspring.config.location=/usr/local/app/${APP_NAME}.yml #使用说明,用来提示输入参数 usage() { echo &quot;Usage: sh 执行脚本.sh app_name [start|stop|restart|status]&quot; exit 1 } #检查程序是否在运行 is_exist(){ pid=`ps -ef|grep java |grep $APP_NAME|grep -v grep|awk '{print $2}' ` echo $pid#如果不存在返回1,存在返回0 if [ -z &quot;${pid}&quot; ]; then return 1 else return 0 fi } #启动方法 start(){ is_exist if [ $? -eq &quot;0&quot; ]; then echo &quot;${APP_NAME} is already running. pid=${pid} .&quot; else nohup java $JVM -jar $APPFILE_PATH $JAR_NAME &gt; ${APP_NAME}.log 2&gt;&amp;1 &amp; fi} #停止方法 stop(){ is_exist if [ $? -eq &quot;0&quot; ]; then kill -9 $pid else echo &quot;${APP_NAME} is not running&quot; fi } #输出运行状态 status(){ is_exist if [ $? -eq &quot;0&quot; ]; then echo &quot;${APP_NAME} is running. Pid is ${pid}&quot; else echo &quot;${APP_NAME} is NOT running.&quot; fi } #重启 restart(){ stop start } #根据输入参数,选择执行对应方法,不输入则执行使用说明 case &quot;$2&quot; in &quot;start&quot;) start ;; &quot;stop&quot;) stop ;; &quot;status&quot;) status ;; &quot;restart&quot;) restart ;; *) usage ;; esac 开机自启，注册成Systemd系统服务使用root权限在linux系统的/lib/systemd/system下编辑需要启动服务如app.service 12345678910111213[Unit]Description=eureka serviceAfter=network.target[Service]Type=simpleExecStart=/usr/bin/java -server -Xms2048m -Xmx2048m -XX:PermSize=1024M -XX:MaxNewSize=512m -XX:MaxPermSize=2048m -Djava.awt.headless=true -XX:+CMSClassUnloadingEnabled -XX:+CMSPermGenSweepingEnabled -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=&lt;服务器IP&gt; -jar -Dspring.config.location=&lt;外置的配置文件地址&gt; &lt;Jar包地址&gt;PrivateTmp=trueUser=&lt;启动服务的用户&gt;Restart=on-failureRestartSec=10[Install]WantedBy=multi-user.target 接下来要做的就是启动服务，首先重新加载systemd 1systemctl daemon-reload 启动该服务,并查看app.service状态 12systemctl start app.servicesystemctl status app.service 配置成开机自启 123systemctl enable app.servicesystemctl stop app.service #关闭systemctl disable app.service #移除开启自启","link":"/2023/09/25/springboot/%E8%B4%A1%E7%8C%AE%E4%B8%80%E4%B8%AAspringboot%E9%A1%B9%E7%9B%AElinux%20shell%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/"},{"title":"SpringCloud版本新旧命名方式","text":"看看SpringCloud已发布版本当前已发布SpringCloud稳定版本见下图，在线查看地址:https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-dependencies SpringCloud新旧命名方式 采用版本名+版本号，其中版本名采用伦敦地铁站命名，其中按照地铁首字母A-Z依次命令如Hoxton.SR9。但是现在已更改为主版本号.次版本号.修订号如2020.0.0 旧版本命名方式中,开发的快照版本(BUILD-SNAPSHOT)到里程碑版本(M),开发的差不多到会发布的候选发布版(RELEASE),最后到正式版(SR)版本。 新版本命名是YYYY.MINOR.MICRO[-MODIFIER]，拿2020.0.1-SNAPSHOT 这个版本来说，其中YYYY为年份全称、MINOR为辅助版本号、MICRO为补丁版本号。MODIFIER同上述修饰关键节点，BUILD-SNAPSHOT、里程碑M等。 SpringCloud与SpringBoot版本对应关系浏览器访问https://start.spring.io/actuator/info，在返回的数据中找到spring-cloud即可以查看SpringCloud与SpringBoot版本对应关系。 SpringCloud版本选择 根据上面的原则首先选择SpringCloud要与SpringBoot版本能够对应的上 SpringCloud应该优先选择SR的版本 采用官网推荐版本，每一个SpringCloud的文档均有推荐SpringBoot版本。如https://docs.spring.io/spring-cloud/docs/2020.0.0/reference/html/ 本人公司的SpringBoot框架使用的2.1.0.RELEASE,SpringCloud选择是Greenwich.SR4(有历史原因)。本系列教程SpringCloud采用Hoxton.SR9,SpringBoot采用 2.3.5.RELEASE。 Springcloud企业项目实战问题汇总系列教程,所有资料和源码均在本人GitHub上，https://github.com/mytianya/springcloud-tutorials","link":"/2023/09/26/springcloud/SpringCloud%E7%89%88%E6%9C%AC%E6%96%B0%E6%97%A7%E5%91%BD%E5%90%8D%E6%96%B9%E5%BC%8F/"},{"title":"微服务架构简介","text":"微服务理论基础-康威法则康威法则：“设计系统的架构受制于产生这些设计组织的沟通结构。”**即系统设计本质上反映了企业的组织机构。系统各个模块间的接口也反映了企业各个部门之间的信息流动和合作方式。 康威法则提出的各定律： 第一定律 组织沟通方式会通过系统设计表达出来 即组织的沟通方式决定了系统的设计方式 第二定律 时间再多一件事情也不可能做的完美，但总有时间做完一件事情 罗马不是一日建成的，学习解决首要问题。产品、软件、模块功能应该首先达到最小可用程度(Minimun Viable Product) 第三定律 线性系统和线型组织架构间有潜在的异质同态特性 这一定律是第一定律的具体应用，具体来说想要什么的系统就搭建什么样的团队，有什么样的团队就搭建什么样的系统。你需要搭建微服务架构的系统，那就需要微服务型的组织架构。每个团队负责自己的部分，对外提供相应的接口，团队间互不干扰，实现完全的**自治**。如此就能降低系统的依赖性，减少通信成本。 第四定律 大的系统组织总是比小系统更倾向分解 系统越复杂，越需要增加人手，人手越多，沟通成本也呈指数增长。分而治之便是大多数公司选择的解决方案。分不同的层级，分不同的小团队，让团队内部完成自治理，然后统一对外沟通。**微服务架构更多是关于组织和团队，而不是技术**。 微服务架构定义微服务架构是一种架构风格，没有单一的定义，随着时间的推移，业界达成已经形成共识，微服务架构的特征包括： 一组小的服务：怎么定义这个小，专注于做好一件事情。在一个单体系统中，避免随着新功能的增加代码库日益庞大，模块之间的界限很难维护，相似的代码随处可见，通常会创建一些抽象层或者模块来保证代码的内聚性。在使用微服务架构时一个微服务同样要具有内聚性这一概念，Robert C.Martin有一个单一职责原则：把因相同原因变化的东西聚合在一起，而把不同原因而变化的东西分开。微服务中独立服务的划分程度，同样有内聚性、单一职责原则，根据业务的边界来确定某个功能代码应该放在那个微服务之中，确定该微服务专注的业务边界之内。 独立的进程：每个服务运行在独立的进程中，能够以进程的方式进行横向扩展。 轻量级通信：服务之间均通过网络调用（HTTP REST/RPC）进行通信，从而加强服务之间的隔离性，避免紧耦合。 基于业务能力：基于业务能力来划分服务的边界。确定对于一个服务来说，我们应该暴露什么，应该隐藏什么。一个服务的变动，应该尽量避免该服务消费者的变动。 独立部署：每个服务模块的开发人员可以进行完全的自治，独自开发、测试、部署。团队之间减少沟通的成本。 无集中式管理：每个团队可以根据各自的业务需要，可以采用不同的技术栈，不同的存储机制，能够高效的完成业务目标即可。 总结来说：微服务架构风格就是小而自治的服务，可以采用不同技术栈，拥有独立进程，进程之间采用网络调用通信，不同团队在业务边界之内开发、测试、部署。 服务架构演进 微服务优点 技术异构性：不同的服务可以采用最适合该服务的技术。 弹性：系统一个服务故障，不会引起级联故障，系统的其他组件还能使用。 扩展：庞大的单块服务只能作为一个整体进行扩展。即使系统中只有一小部分存在性能问题，也需要对整个服务进行扩展。如果使用较小的多个服务，则可以只对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在更小的、性能稍差的硬件上。 简化部署 更小粒度的服务粒度，带来的易于重用已有的功能 服务更改维护代价更小 微服务缺点 服务间的通信成本。 分布式系统的复杂性。 服务的运维管理。 分布部署服务出错,问题的定位追踪。 微服务支撑组件微服务只是一种架构手段，当我们将一个单体系统拆分成微服务架构风格时，微服务架构的带来问题该如何解决呢？比如服务进程之间的通信、服务之间错中复杂的依赖关系导致的线上问题如何排查、分布式系统带来的一致性问题等问题。因此微服务产生了一些系列的支撑组件： 服务治理 服务负载均衡 服务网关 熔断、限流、降级 服务分布式链路跟踪 统一配置管理 微服务组件选型注册中心选型 Nacos Eureka Consul 一致性协议 CP+AP AP CP 健康检查 TCP/HTTP/MYSQL/Client Beat Client Beat HTTP/gRPC/TCP 负载均衡策略 权重 Ribbon Fabio 雪崩保护 有 有 无 自动注销实例 支持 支持 不支持 集群 支持 支持 支持 SpringCloud集成 支持 支持 支持 Dubbo集成 支持 不支持 不支持 K8s集成 支持 不支持 支持 备注 阿里开源产品，JAVA语言开发，持续维护 SpringCloud Netffix组件，java语言开发Eureka2.0不在维护 国外HashiCorp公司，GO语言开发，持续维护 负载均衡组件选型 Ribbon Springcloud load balancer Nginx 负载方式 客户端负载 客户端负载 服务端负载 原理 每个客户端维护访问的服务清单 每个客户端维护访问的服务清单 服务端维护一个可用服务清单 使用方式 客户端配置负载均衡策略：权重、随机、轮询、自定义规则 客户端配置负载均衡策略：权重、随机、轮询、自定义规则 服务端配置规则 备注 Netffix开源产品,进入维护状态 SpringCloud2020.0.x版本后开发的新负载均衡器 传统的服务的负载均衡组件 服务网关选型 Zuul SpringCloud Gateway Kong 开发语言 JAVA JAVA Lua 使用方式 自己开发Filter 自己开发Filter 插件 界面管理 不支持 不支持 支持 协议 HTTP/HTTPS HTTP/HTTPS/WEBSOCKET HTTP/HTTPS/WEBSOCKET 功能 限流、动态路由、灰度发布、日志等功能自己开发 限流、动态路由、灰度发布、日志等功能自己开发 插件+自定义规则开发 备注 Nettfix组件，Zuul1.0基于Serlvet,Zuul2.0支持异步 SpringCloud组件，Webflux异步 OpenRestry+Lua二次开发 配置中心选型 SpringCloud Config Apollo Nacos 开发语言 JAVA JAVA JAVA 存储方式 GIT仓库\\MYSQL MYSQL MYSQL 版本管理 GIT 自动管理 自动管理 推送机制 SpringCloud BUS HTTP长轮询 HTTP长轮询 权限管理 支持 支持 不支持 备注 SpringCloud全家桶组件 携程开源，功能非常丰富权限管理、命名空间、多语言。集群部署可整合现有Eureka 阿里开源，功能较简单，但是本身带注册中心功能。 熔断组件选型 SpringCloud Alibaba Sentinel Hystrix SpringCloud Resilience4j 隔离策略 信号量隔离（并发控制） 线程池隔离/信号量隔离 信号量隔离 熔断降级策略 基于慢调用比例、异常比例、异常数 基于异常比例 基于异常比例、响应时间 实时统计实现 滑动窗口（LeapArray） 滑动窗口（基于 RxJava） Ring Bit Buffer 动态规则配置 支持多种数据源 支持多种数据源 有限支持 扩展性 多个扩展点 插件的形式 接口的形式 基于注解的支持 支持 支持 支持 限流 基于 QPS，支持基于调用关系的限流 有限的支持 Rate Limiter 流量整形 支持预热模式与匀速排队控制效果 不支持 简单的 Rate Limiter 模式 系统自适应保护 支持 不支持 不支持 多语言支持 Java/Go/C++ Java Java Service Mesh 支持 支持 Envoy/Istio 不支持 不支持 控制台 提供开箱即用的控制台，可配置规则、实时监控、机器发现等 简单的监控查看 不提供控制台，可对接其它监控系统 服务调用链路追踪组件选型 Zipkin CAT Skywalking OpenTracing 兼容 支持 不支持 支持 开发语言 JAVA JAVA JAVA 侵入性 高 高 低 WebUI丰富度 低 高 高 监控报警 不支持 支持 支持 备注 SpringCloud全家桶组件 美团开源 Apache 微服务架构图图片来源互联网：https://www.owensun.com/microservice-refercence-architecture/ 参考文章 [1] 微服务理论 [2] 康威法则","link":"/2023/09/26/springcloud/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/"},{"title":"ORA-00257归档程序错误","text":"线上生成系统后台日志连接数据库报ORA-00257归档程序错误。借此了解下oracle日志归档模式和非归档模式以及如何解决该问题。 Oracle日志操作模式Oracle数据库在运行过程中，每一个实例都有一个相关的重做日志，在实例故障情况下保护数据库。我们对数据的DML,DDL操作都会结构化为重做记录，可以用来重建对数据库所做的所有更改的数据，包括撤销段。重做记录在SGA的重做日志缓冲区中以循环方式进行缓冲，并被数据库后台进程log Writer (LGWR)写入其中一个重做日志文件（Redo log files）中由数据库库后台进程log Writer(LGWR)写入联机重做日志（Redo log files）中，当重做日志文件被填满时，会发生日志切换，根据是否启用归档分为两种情况： 1、如果归档被禁用（NOARCHIVELOG模式），则在将在记录在其中的更改写入数据文件后，这个填满的重做日志文件可用。 2、如果启用了归档（ARCHIVELOG模式），则在将记录的更改写入数据文件并归档后，LGWR就可以使用这个被填满的重做日志文件。 归档优缺点可以进行完全、不完全恢复：由于对数据库所做的全部改动都记录在日志文件中，如果发生硬盘故障等导致数据文件丢失的话，则可以利用物理备份和归档日志完全恢复数据库，不会丢失任何数据。 一般生产系统推荐都开启归档模式，毕竟数据无价。 归档常用操作查看当前数据库归档模式1234su - oracle #切换到oracle用户sqlplus /nologconn /as sysdba;select log_mode from v$database; 开启归档模式12345shutdown immediate; #关闭数据库startup mount; #启动数据库到mount状态alter database archivelog; #修改数据库到归档模式alter database open; #启动数据库archive log list; #查看归档配置 解决ORA-00257问题项目上面ORA-00257归档程序错误，为归档空间不足。解决办法：1、删除多余的归档日志2、增大归档日志的容量3、关闭归档模式 删除多于归档日志1、查看当前使用archivelog使用的百分比。 12set linesize 200;select * from V$FLASH_RECOVERY_AREA_USAGE; 2、查看当前归档日志所在目录当前归档日志文件在/home/oracle/fast_recovery_area/AODB/archivelog/目录下 1show parameter recovery; 3、在此目录下根据日期删除过久的归档日志4、使用rman维护控制文件 123rman target &lt;管理员用户&gt;/&lt;管理员密码&gt;crosscheck archivelog all; #检查错误文档delete expired archivelog all; #删除过期文档 修改归档日志存储大小跟容量12show parameter db_recover;alter system set db_recovery_file_dest_size=2000G scope=spfile 关闭归档模式如果不是生产系统而是测试环境，可以关闭归档模式 12345shutdown immediate; #关闭数据库startup mount; #启动数据库到mount状态alter database noarchivelog; #修改数据库到归档模式alter database open; #启动数据库archive log list; #查看归档配置 项目真实造成归档满原因实际项目提供的归档大小为1T按照目前项目量没有这么大的日志。在线上归档日志1T一天就打满了。 联想到最近对程序升级过，部分软件模块中可能存在频繁的DML操作。 通过记录了几个小时的AWR日志，下载下来查看程序中存在不正常的SQL更新语句，造成了频繁的更新产生了大量的日志，修复了此SQL问题，解决了该问题。","link":"/2023/09/28/oracle/ORA-00257%E5%BD%92%E6%A1%A3%E7%A8%8B%E5%BA%8F%E9%94%99%E8%AF%AF/"},{"title":"搭建一个点播跟直播流媒体服务器玩玩","text":"现在抖音、快手等直播实在是太火了，因此对音视频的开发非常感兴趣，查阅了相关资料，使用Nginx搭建一个简单的直播跟点播流媒体服务器，能够实时推流到服务器，同时在网页端播放直播的视频。 先上效果​ 使用OBS软件录制电脑桌面操作推流到自己搭建的流媒体服务器，然后在网页拉流播放。当然也可以采集摄像头、麦克风推流，或者推送本地视频到流媒体服务器。 搭建步骤Ubuntu18.04安装nginx-flv模块扩展这里我是用虚拟机安装了Ubuntu18.04先下载nginx1.19.3的源码与nginx-http-flv-module的源码。 12wget https://github.com/winshining/nginx-http-flv-module/archive/master.zipwget http://nginx.org/download/nginx-1.19.3.tar.gz &amp;&amp; tar -zxvf nginx-1.19.3.tar.gz 解压下载的个源码进行编译，这样一个Nginx搭建的流媒体服务器就好了。 12345cd nginx-1.19.3 #进入nginx源码目录./configure --add-module=../nginx-http-flv-module-mastervim objs/Makefile #删除-Werrormakemake install 进行点播与直播配置​ 上面已经安装好了nginx，编辑/usr/local/nginx/conf/nginx.conf进行相关配置。这里直接贴出完整的配置。其中rtmp为开启rtmp服务功能，并且为了能够在网页端播放开启了hls。推流的rmtp流会转换成hls协议的ts切片，保存在服务器上，nginx配置了location让网页能够访问切好的hls切片。 ​ 这里解释下rtmp是adobe的私有协议，必须使用flash播放。hls是苹果开发的视频传输协议使用http进行传输。ios跟android支撑的都很好，一般进行跨平台直播使用hls协议比较常见。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#user nobody;worker_processes 1;events { worker_connections 1024;}rtmp { #RTMP服务 server { listen 1935; #//服务端口 chunk_size 4096; #//数据传输块的大小 application vod { play /opt/video/vod; #//视频文件存放位置。 } application live{ live on; #直播 hls on; #把直播服务器改造成实时回发服务器,视频切片成ts wait_key on; #对视频切片进行保护 hls_path /opt/video/rtmp/hls; #ts切片存放位置 hls_fragment 10s; #切片大小 hls_playlist_length 60s; #回看的时间 hls_continuous on; #连续模式 hls_cleanup on; #对多余切片进行删除 hls_nested on; #嵌套模式 } }}http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 80; server_name localhost; location /stat { #第二处添加的location字段。 rtmp_stat all; rtmp_stat_stylesheet stat.xsl; } location /stat.xsl { #第二处添加的location字段。 root /usr/local/nginx-http-flv-module/; } location /hls { types { application/vnd.apple.mpegurl m3u8; video/mp2t ts; } alias /opt/video/rtmp/hls; add_header Cache-Control no-cache; add_header Access-Control-Allow-Origin *; } location / { root html; index index.html index.htm; }} 进行测试使用obs推流推送到rtmp://192.168.227.128/live串流密钥随便填写即可。 ​ h5网页端采用video.js进行播放直播流视频,这里的播放的地址是切好片的m3u8文件地址，m3u8存放了每一个小切片的地址。 123456789101112131415&lt;body&gt; &lt;video id=example-video width=600 height=300 class=&quot;video-js vjs-default-skin&quot; controls&gt; &lt;source src=&quot;http://192.168.227.128/hls/test/index.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt; &lt;/video&gt; &lt;link href=&quot;//vjs.zencdn.net/7.8.2/video-js.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;script src=&quot;//vjs.zencdn.net/7.8.2/video.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;videojs-contrib-hls.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/browse/@videojs/http-streaming@2.2.3/dist/videojs-http-streaming.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var player = videojs('example-video'); player.play(); &lt;/script&gt; &lt;/body&gt; ​ 上面的nginx配置还配置了本地视频文件点播配置，把视频文件放在/opt/video/vod位置，使用vlc填写rtmp://192.168.227.128/vod/qlgame.mp4进行播放即可。 以上搭建只是测试学习使用，实际音视频开发涉及采集、编码、推流、传输、拉流、解码等等过程，每一个过程都设计许多知识。后面音视频开发学习笔记，等我攒了一些笔记发出来互相学习。","link":"/2023/09/27/video/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%82%B9%E6%92%AD%E8%B7%9F%E7%9B%B4%E6%92%AD%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%A9%E7%8E%A9/"}],"tags":[{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"小根堆","slug":"小根堆","link":"/tags/%E5%B0%8F%E6%A0%B9%E5%A0%86/"},{"name":"springboot","slug":"springboot","link":"/tags/springboot/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"ora-00257","slug":"ora-00257","link":"/tags/ora-00257/"},{"name":"音视频","slug":"音视频","link":"/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"}],"categories":[{"name":"杂谈","slug":"杂谈","link":"/categories/%E6%9D%82%E8%B0%88/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"oracle","slug":"oracle","link":"/categories/oracle/"},{"name":"流媒体","slug":"流媒体","link":"/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"}],"pages":[{"title":"关于我","text":"全栈工程师-联系我，请发邮件，邮箱地址：dsyslove@163.com","link":"/about/index.html"}]}